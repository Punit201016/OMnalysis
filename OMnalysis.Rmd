---
title: "OMNALYSIS"
output:
  flexdashboard::flex_dashboard:
    theme: simplex
    orientation: rows
    vertical_layout: fill
    Runtime: shiny
runtime: shiny
resource_files:
- biocartaEx1SPIA.RData
- nciEx1SPIA.RData
- pantherEx1SPIA.RData
- pharmgkbEx1SPIA.RData
- reactome_ids.RData
---

```{r setup, include=FALSE}
library(flexdashboard)
library(shiny)
library(shinydashboard)
library(dplyr)
library(shinythemes)
library(DT)
library(slickR)
```

Welcome
==========================================
Column{data-height=430}
------------------------------------------
### Introduction
```{r, echo=FALSE}

div(h3(strong("Welcome to OMnalysis"), style = "display: inline; font-family: 'Lobster', cursive;font-weight: 500; line-height: 1.1; margin-top: 20px; margin-bottom: 20px; color: #4d3a7d;"), h6("An integrated web application to explore quantitative differential omics data!"))

h5(p(strong("OMnalysis is powered with well established and highly used R Bioconductor packages to mine faithful biological information from the differential omics data.")))
h5(strong("Upload the differential omics data upto four treatments and with few clicks see the magic!"))

h4(strong("Features"), style = "font-family: 'Lobster', cursive;color: #4d3a7d; margin-top: 0px;")
h6(strong("1. User friendly with multiple additional options."))
h6(strong("2. Currently support four species (Human, Cow, Pig and Chicken)."))
h6(strong("3. Most upto date accession ID conversion."))
h6(strong("4. Pulication ready high resoltution images."))
```

### Support
```{r,echo=FALSE}

img(src = "./www/MANNA_logo.png", height = 150, width = 730)
br()

h5(p(strong("This project has received funding from the European Union’s Horizon 2020 research and innovation programme H2020-MSCA- ITN-2017- EJD: Marie Skłodowska-Curie Innovative Training Networks (European Joint Doctorate) – Grant agreement nº: 765423 – MANNA.")))

```

Column {data-height=570}
------------------------------------------
### Plots
```{r, echo=FALSE}
output$slickr <- renderSlickR({ 
    imgs <- list.files("./www/om_panel/", pattern=".png", full.names = TRUE)
    slickR(imgs, width = 1700, height = 330) + settings(autoplay = TRUE)
  })


slickROutput("slickr")

  
```

### Omnalysis workflow
```{r, echo=FALSE}

img(src = "./www/OMnalysis_1.png", height = 365, width = 730)

```

Upload data
==========================================
Sidebar {.sidebar data-width=350} 
-------------------------------------------
```{r, echo=FALSE}
br()

shinyjs::useShinyjs(rmd = TRUE)
div(style = "width: 150px;", actionButton(inputId = "uploaded_ex", "Differentially expressed example data"))

br()
div(.progress = {"height: 0px;"}, fileInput(inputId = "inFile", label = h5(strong("Upload Expression Data")),
multiple = TRUE, accept = c(
                    "text/csv",
                    
                    "text/comma-separated-values",
                    "text/plain",
                    ".csv")))


actionLink("reset_1", strong("Reset"))

selectInput("select1", label = h5 (strong("Select a species")), choices = c("Human" = 1, "Chicken"= 2, "Pig"= 3, "Cow"= 4), selected = NULL)


div(style = "display: inline-block; width: 150px;", selectInput("select2", label = h5(strong("ID conversion")), choices = c("Ensembl gene ID")))

div(style = "display: inline-block; width: 150px;", selectInput("select3", label = "", choices = c("Ensembl gene ID" = 1, "Gene name"= 2, "HGNC symbol"= 3, "Gene description" = 4, "UniProtKB/Swiss-Prot ID" = 5), selected = NULL))

actionButton("ID_submit", "Submit")

br()
downloadButton(outputId = "downloadData", label = "Download",  icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")


downloadHandler(
filename = function(){
paste("Converted ID", ".csv", sep = "")
},
content = function(file){
write.csv(data_list_2(), file, row.names = FALSE)
}
)


br()
strong(p("ALERT:- Gene ID conversion is mandatory for further analysis."))

rmarkdown::render_delayed({
library(EnhancedVolcano)
library(tidyr)
library(biomaRt)
library(tidyverse)
library(gplots)
library(tibble)
library(gridExtra)
library(RColorBrewer)
library(devtools)
library(ggbiplot)
library(factoextra)
library(ggplot2)
library(clusterProfiler)
library(org.Hs.eg.db)
library(data.table)
library(VennDiagram)
library(fields)
library(wordcloud)
library(org.Gg.eg.db)
library(org.Ss.eg.db)
library(org.Bt.eg.db)
library(ReactomePA)
library(reactome.db)
library(europepmc)
library(pathview)
library(SPIA)
library(shinyjs)
library(futile.logger)
library(SBGNview)
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")
set.seed(1234)
})

```

TAB {.tabset}
-----------------------------------------
### Data output
```{r, echo=FALSE}

rv <- reactiveValues(data = NULL)


observe({
  req(input$inFile)
  rv$data <- read.csv(input$inFile$datapath)
})

observe({
  req(input$uploaded_ex)
  rv$data <- read.csv("Test_t.csv")
  })

observeEvent(input$reset_1, {
  rv$data <- NULL
  reset("inFile")
})

observeEvent(input$reset_1, {
  rv$data <- NULL
  reset("uploaded_ex")
})


datasetInput <- reactive({
rv$data
})


data_list_1 <- eventReactive(input$ID_submit, {

#selection from the user
if (input$select1 == 1) {species_dataset <- "hsapiens_gene_ensembl"} 
else if (input$select1 == 2) {species_dataset <- "ggallus_gene_ensembl"}
else if (input$select1 == 3) {species_dataset <- "sscrofa_gene_ensembl"}
else if (input$select1 == 4) {species_dataset<- "btaurus_gene_ensembl"}


ensembl <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset =  species_dataset, host = "uswest.ensembl.org")})


data_list_2 <- eventReactive(input$ID_submit, {

#Selection of the attributes from the user(geneID) TAB-2
if (input$select3 == 1) {species_attributes <- "ensembl_gene_id"} 
else if (input$select3 == 2) {species_attributes <- "external_gene_name"}
else if (input$select3 == 3) {species_attributes <- "hgnc_symbol"}
else if (input$select3 == 4) {species_attributes <- "description"}
else if (input$select3 == 5) {species_attributes <- "uniprotswissprot"}


#mapping of the input data to the 
Mapped_gene  <- getBM(attributes =  c("ensembl_gene_id", species_attributes), filters = "ensembl_gene_id", values = datasetInput(), mart = data_list_1())

Converted_gene_id <- merge(datasetInput(), Mapped_gene, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
})



output$Table_output_1 <- DT::renderDataTable({ 
  

if(input$ID_submit > 0){
withProgress(message = "ID conversion is in Progress",  detail = "Fetching data from ensembl!", value = 0,
     {
       for(i in 1:10)
       {incProgress(1/15)
         Sys.sleep(0.2)}
       
       data_list_2()
     })
}

else return(datasetInput())

}, options = list(scroller = TRUE, scrollY = 510, scrollX = TRUE, pageLength = 25))

DT::dataTableOutput("Table_output_1") 

output$downloadData <- downloadHandler(
filename = function() {
paste0("Converted ID", ".csv", sep = "")
},
content = function(file)
{write.csv(data_list_2(), file, row.names = FALSE)
}
)
```

PCA
=========================================================== 
Sidebar {.sidebar data-width=350} 
----------------------------------------------------------
```{r, echo=FALSE}

checkboxGroupInput(inputId = "PCA_M", label = h5(strong("Principal component analysis")), choices = c("Variables PCA", "Biplot PCA"), inline = TRUE)

div(style = "display: inline-block; width: 150px;", selectInput("PCA_C", label =  h5(strong("Compare PCA only for biplot")), choices = c("PC1" = 1, "PC2"= 2, "PC3"= 3, "PC4" = 4), selected = 1))

div(style = "display: inline-block; width: 150px;", selectInput("PCA_C_2", label = "", choices = c("PC1" = 1, "PC2"= 2, "PC3"= 3, "PC4" = 4), selected = 2))

selectInput(inputId = "select_PCA", label = h5(strong("Format")), choices = c("jpeg", "png", "pdf", "tiff"))

fluidRow(column (4, numericInput(inputId = "Download_PCA_input1",  label = h6("width"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_PCA_input2",  label = h6("height"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput(inputId = "Download_PCA_input3",  label = h6("resolution"), value = 300, min = 150, max = 500, step = 50, width = '100%')))


downloadButton(inputId = "PCA_plot", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")

downloadHandler(
filename = function(){
paste("PCA plot", input$select_PCA, sep = ".")
},

content = function(file){
{ggsave(file, plot(Plot_PCA_1()), device = input$select_PCA, width = input$Download_PCA_input1, height = input$Download_PCA_input2, units = "cm", dpi = input$Download_PCA_input3)}
}
)

```

TAB {.tabset}
--------------------------------------------
### Plot visualization
```{r, echo=FALSE}

Plot_PCA_1 <- reactive({

PCA_T1 <- data_list_2()[, -c(1,3,4,6,7,9,10,12,13,15,16)]
PCA_T1.pca <- prcomp(PCA_T1[, -ncol(PCA_T1)], scale. = TRUE, center = TRUE)


if (input$PCA_M == "Variables PCA"){
PCA_plot_VA <- fviz_pca_var(PCA_T1.pca, col.var = "contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
}

else if(input$PCA_M == "Biplot PCA"){
  
PCA_T1$col <- suppressWarnings(factor(colnames(PCA_T1)[apply(PCA_T1, 1L, which.max)]))

PCA_plot <- ggbiplot(PCA_T1.pca, choices = c(input$PCA_C:input$PCA_C_2), scale = 1, groups = PCA_T1$col, ellipse = TRUE,varname.adjust = 1, varname.size = 6, labels = data_list_2()[, ncol(data_list_2())] )+ theme_bw()+ theme(text = element_text(size=20)) + scale_color_discrete(name = '') + theme(legend.direction = 'horizontal', legend.position = 'top') + scale_x_continuous(breaks = seq(-20, 20, by = 2)) + scale_y_continuous(n.breaks = 10)}
})


output$PCA_plot_1 <- renderPlot({

validate(need(input$PCA_M != "", "Please select type of PCA visualization to generate plot."))    

if (input$PCA_M == "Biplot PCA"){withProgress(message = "Constructing PCA biplot ", detail = "between the user selected Principal componenets!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Plot_PCA_1())}
  
else if(input$PCA_M == "Variables PCA"){withProgress(message = "Constructing plot between the variables ", detail = "PCA plot between the uploaded treatments!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Plot_PCA_1())}

})
plotOutput("PCA_plot_1")



output$PCA_plot <- downloadHandler(
filename = function(){
paste("PCA plot", input$select_PCA, sep = ".")
},

content = function(file){
{ggsave(file, plot(Plot_PCA_1()), device = input$select_PCA, width = input$Download_PCA_input1, height = input$Download_PCA_input2, units = "cm", dpi = input$Download_PCA_input3)}
}
)

```

Plots
=========================================================
Sidebar {.sidebar data-width=350} 
----------------------------------------------------------
```{r, echo=FALSE}

tags$style(
HTML(
  ".checkbox-inline { 
              margin-left: 0px;
              margin-right: 20px;
              padding-right: 0px;
    }
   .checkbox-inline+.checkbox-inline {
              margin-left: 0px;
              margin-right: 20px;
   }
    
  "
)
) 

tags$style(
HTML(".control-label{
  align = left;
}"
)
)
         
  

 

tags$div(class = "checkbox-inline; .control-label;",checkboxGroupInput(inputId = "T_plot", label = h5(strong("Uploaded treatments")), choices = list("Treatment-1" = 1, "Treatment-2" = 2, "Treatment-3" = 3, "Treatment-4" = 4), inline = TRUE))

fluidRow(column (5, numericInput( inputId = "slider_1", label =  h5(strong("P-value cutoff ")), min = 0, max = 0.5, value = 0.001, step = 0.01, width = "100%")),

column(5, numericInput( inputId ="slider_2", label= h5(strong("FC-cutoff")), min = 0, max = 15, value = 1.2 , step = 0.5, width = "100%")))

textInput(inputId = "text1", label = h5(strong("Plot Title")), value = "please fill main title")

checkboxGroupInput(inputId = "checkbox", label = h5(strong("Plots")), choices = c("Scatter plot", "Volcano plot", "Table"), inline = TRUE)

selectInput(inputId = "select4", label = h5(strong("Format")), choices = c("jpeg", "png", "pdf", "tiff"))

fluidRow(column (4, numericInput( inputId = "Download_plot_input1",  label = h6("width"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_plot_input2",  label = h6("height"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput(inputId = "Download_plot_input3",  label = h6("resolution"), value = 300, min = 150, max = 500, step = 50, width = '100%')))


downloadButton(inputId = "Plot_Volcano_1", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")

downloadHandler(
filename = function(){
paste(input$text1, input$select4, sep = ".")
},

content = function(file){
if(input$checkbox == "Scatter plot"){ggsave(file,  
plot(Plot_scatter_1()), device = input$select4, width = input$Download_plot_input1, height = input$Download_plot_input2, units = "cm", dpi = input$Download_plot_input3)}
else if(input$checkbox == "Volcano plot"){ggsave(file, plot(Volcano_plot_1()) , device = input$select4, width = input$Download_plot_input1, height = input$Download_plot_input2, units = "cm", dpi = input$Download_plot_input3)}

}
)

```

Column {.tabset}
----------------------------------------------------------
### Scatter Plot
```{r, echo= FALSE}

converted_data <- eventReactive(input$T_plot == TRUE, {

Treatment_1 <- as.data.frame(data_list_2())

if (input$T_plot == 1){T_plot_1 <- Treatment_1[, c(1:4, ncol(Treatment_1))]}
else if (input$T_plot == 2){T_plot_1 <- Treatment_1[, c(1, 5:7, ncol(Treatment_1))]}
else if (input$T_plot == 3){T_plot_1 <- Treatment_1[, c(1, 8:10, ncol(Treatment_1))]}
else if (input$T_plot == 4){T_plot_1 <- Treatment_1[, c(1, 11:13, ncol(Treatment_1))]}

})

Plot_scatter_1 <- reactive({
if (input$checkbox == "Scatter plot"){
converted_1 <- as.data.frame(converted_data()) 
converted_1$Differential_Expression <- "Non-significant"
converted_1$Differential_Expression[converted_data()[, 2] > input$slider_2] <- "Up"
converted_1$Differential_Expression[converted_data()[, 2] < -(input$slider_2)] <- "Down"
 
g1 <- ggplot(data = converted_data(), aes(x = converted_1[, 3], y = converted_1[, 2], col= converted_1$Differential_Expression)) + geom_point(size = 3)+ scale_x_continuous(breaks = seq(-20, 20, by = 2)) + scale_y_continuous(n.breaks = 10) + theme_bw() + xlab("logCPM") + ylab("logFC") + scale_color_manual(name = "Differential Expression", values = c("red", "black","green")) + theme(text = element_text(size=20), plot.title = element_text(hjust = 0.5)) + ggtitle(input$text1)
}
})

output$plot_scatter <- renderPlot({

validate(
need(input$T_plot != "", "Please select the treatment for generating plot!"), 

need(input$checkbox != "", "Please select the type of plot.")
)

if(input$checkbox == "Scatter plot"){withProgress(message = "Constructing scatter plot.", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Plot_scatter_1())}

})

plotOutput("plot_scatter")


```

### Volcano Plot
```{r, echo= FALSE}

Volcano_plot_1 <- reactive({if(input$checkbox == "Volcano plot"){ 
g2 <- EnhancedVolcano(toptable = converted_data(), lab = converted_data()[, 5],  x = names(converted_data()[2]), y = names(converted_data()[4]), pCutoff = input$slider_1, titleLabSize = 20, title = input$text1, FCcutoff = input$slider_2, labhjust = 0.5, labSize = 4) + scale_x_continuous(breaks = seq(-20, 20, by = 2)) + scale_y_continuous(n.breaks = 10)
}
})

output$plot_volcano <- renderPlot({

validate(

need(input$T_plot != "", "Please select the treatment for generating plot!"), 

need(input$checkbox != "", "Please select the type of plot.")
)

if (input$checkbox == "Volcano plot"){
withProgress(message = "Constructing Volcano plot!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Volcano_plot_1())
}

})

plotOutput("plot_volcano")
```

### table out
```{r, echo=FALSE}

gene_Table_1 <- eventReactive(input$T_plot == TRUE,{
Treatment_1 <- as.data.frame(data_list_2())

if (input$T_plot == 1){T_plot_1 <- Treatment_1[, c(1:4, ncol(Treatment_1))]}
else if (input$T_plot == 2){T_plot_1 <- Treatment_1[, c(1, 5:7, ncol(Treatment_1))]}
else if (input$T_plot == 3){T_plot_1 <- Treatment_1[, c(1, 8:10, ncol(Treatment_1))]}
else if (input$T_plot == 4){T_plot_1 <- Treatment_1[, c(1, 11:13, ncol(Treatment_1))]}

})
output$converted_data <- DT::renderDataTable({

validate(need(input$T_plot != "", "Please select the treatment to show table with converted IDs!"),   

need(input$checkbox != "", "Please select the table option to show.")) 

if(input$checkbox == "Table"){gene_Table_1()}}, options = list(scroller = TRUE, scrollY = 510, scrollX = TRUE, pageLength = 25))

DT::dataTableOutput("converted_data")


# download function of plots
output$Plot_Volcano_1 <- downloadHandler(
filename = function(){
paste(input$text1, input$select4, sep = ".")
},

content = function(file){
if(input$checkbox == "Scatter plot"){ggsave(file,  
plot(Plot_scatter_1()), device = input$select4, width = input$Download_plot_input1, height = input$Download_plot_input2, dpi = input$Download_plot_input3, units = "cm")}
else if(input$checkbox == "Volcano plot"){ggsave(file, plot(Volcano_plot_1()) , device = input$select4, width = input$Download_plot_input1, height = Download_plot_input2, dpi = input$Download_plot_input3, units = "cm")}
})

```

Statistical filtering
========================================
Sidebar {.sidebar data-width=350} 
-----------------------------------------
```{r, echo=FALSE}


checkboxGroupInput(inputId = "T1_filter", label = h5(strong("Treatments uploaded")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"), inline = TRUE)

h5(strong("Statistical filtering"))

fluidRow(column (4, numericInput( inputId = "Numeric_input1",  label = h6("LogFC"), value = 0, min = 0, max = 25, step = 0.5, width = '100%')),
column (4, numericInput( inputId = "Numeric_input2",  label = h6("LogCPM"), value = 0, min = -15, max = 25, step = 0.5, width = '100%')),
column (4, numericInput( inputId = "Numeric_input3",  label = h6("P-Value"), value = 0, min = -20, max = 20, step = 0.01, width = '100%')))

checkboxGroupInput(inputId = "checkbox_2", label = h5(strong("Venn Diagram")), choices = list("Split into Up and Down-regulated", "VennDiagram"), inline = FALSE)


fluidRow(column (4, numericInput( inputId = "Download_input1",  label = h6("width"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_input2",  label = h6("height"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_input3",  label = h6("resolution"), value = 300, min = 100, max = 600, step = 50, width = '100%')))



downloadButton(inputId = "Downloadplot_1", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")

downloadHandler(
filename =function(){paste("Venn Diagram", tolower(input$select_format), sep = ".")
},

content = function(file){
if (input$select_format == "jpeg")
{jpeg(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "png")
{png(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "pdf")
{pdf(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "tiff")
{tiff(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
}
)

checkboxGroupInput(inputId = "checkbox_3", label = h5(strong ("Histogram")), choices = list("Treatment", "All Treatments"), inline = TRUE)

textInput(inputId = "text2", label = h5(strong("Title")), value = "")

selectInput(inputId = "select_format", label = h5(strong("Format")), choices = c("jpeg", "png", "pdf", "tiff"))



downloadHandler(
filename =function(){paste("Histogram", tolower(input$select_format), sep = ".")
},

content = function(file){
if(input$checkbox_3 == "Treatment"){ggsave(file, plot(Histogram_plot_1()), device = tolower(input$select_format), width = input$Download_input1, height = input$Download_input2, dpi = input$Download_input3, units = "cm")}

else if(input$checkbox_3 == "All Treatments"){ggsave(file, plot(Histogram_plot_all()), device = tolower(input$select_format), width = input$Download_input1, height = input$Download_input2, dpi = input$Download_input3, units = "cm")}

}
)
```

Column {.tabset}
----------------------------------------------------
### Filtered data
```{r, echo= FALSE}

Filtertable1 <- reactive({
df_1 <- as.data.frame(data_list_2())
df_2 <- dplyr::select(.data = df_1, ENSEMBLGENE, logFC, logCPM, PValue)
filter(.data = df_2, 
logFC > input$Numeric_input1 | logFC < -(input$Numeric_input1), 
logCPM >= input$Numeric_input2, 
PValue < input$Numeric_input3) %>% unique()
})

Filtertable2 <- reactive({
df_1 <- as.data.frame(data_list_2())
df_2 <- dplyr::select(.data = df_1, ENSEMBLGENE, logFC.1, logCPM.1, PValue.1)
filter(.data = df_2, 
logFC.1 > input$Numeric_input1 | logFC.1 < -(input$Numeric_input1), 
logCPM.1 >= input$Numeric_input2, 
PValue.1 < input$Numeric_input3) %>% unique()
})

Filtertable3 <- reactive({
df_1 <- as.data.frame(data_list_2())
df_2 <- dplyr::select(.data = df_1, ENSEMBLGENE, logFC.2, logCPM.2, PValue.2)
filter(.data = df_2, 
logFC.2 > input$Numeric_input1 | logFC.2 < -(input$Numeric_input1), 
logCPM.2 >= input$Numeric_input2, 
PValue.2 < input$Numeric_input3) %>% unique()
})

Filtertable4 <- reactive({
df_1 <- as.data.frame(data_list_2())
df_2 <- dplyr::select(.data = df_1, ENSEMBLGENE, logFC.3, logCPM.3, PValue.3)
filter(.data = df_2, 
logFC.3 > input$Numeric_input1 | logFC.3 < -(input$Numeric_input1), 
logCPM.3 >= input$Numeric_input2, 
PValue.3 < input$Numeric_input3) %>% unique()
})


filter_data <- reactive({
if (input$T1_filter == "Treatment-1"){Filtertable1()}
else if (input$T1_filter == "Treatment-2"){Filtertable2()}
else if (input$T1_filter == "Treatment-3"){Filtertable3()}
else if (input$T1_filter == "Treatment-4"){Filtertable4()}
})

output$filtered_data <- DT::renderDataTable({

validate(need(input$T1_filter != "" , "Please select the treatment to view filtered table!"))   

df_filter <- as.data.frame(filter_data())
df_filter
}, options = list(scroller = TRUE, scrollY = 400, scrollX = TRUE, pageLength = 20))

DT::dataTableOutput("filtered_data")
```

### Venn Diagram
```{r, echo= FALSE}

df_3 <- reactive({as.data.frame(Filtertable1(), stringsAsFactors = TRUE)})
A_1 <- reactive({df_3()[, 1] %>% unlist()})

A <- reactive({dplyr::select(filter(.data = df_3(), logFC > 0), 1) %>% unlist()})
B <- reactive({dplyr::select(filter(.data = df_3(), logFC < 0), 1) %>% unlist()})

df_4 <- reactive({as.data.frame(Filtertable2(), stringsAsFactors = TRUE)})
A_2 <- reactive({df_4()[, 1] %>% unlist()})
C <- reactive({dplyr::select(filter(.data = df_4(), logFC.1 > 0), 1) %>% unlist()})
D <- reactive({dplyr::select(filter(.data = df_4(), logFC.1 < 0), 1) %>% unlist()})

df_5 <- reactive({as.data.frame(Filtertable3(), stringsAsFactors = TRUE)})
A_3 <- reactive({df_5()[, 1] %>% unlist()})
E <- reactive({dplyr::select(filter(.data = df_5(), logFC.2 > 0), 1) %>% unlist()})
G <- reactive({dplyr::select(filter(.data = df_5(), logFC.2 < 0), 1) %>% unlist()})

df_6 <- reactive({as.data.frame(Filtertable4(), stringsAsFactors = TRUE)})
A_4 <- reactive({df_6()[, 1] %>% unlist()})
H <- reactive({dplyr::select(filter(.data = df_6(), logFC.3 > 0), 1) %>% unlist()})
I <- reactive({dplyr::select(filter(.data = df_6(), logFC.3 < 0), 1) %>% unlist()})




VENN_plot_1 <- eventReactive(input$checkbox_2 == "Split into Up and Down-regulated", {


observeEvent(input$checkbox_2 == "Split into Up and Down-regulated", {
showNotification("Please select atleast two treatments to generate venn diagram.",  type = "message", duration = 10)
})  
  
if(all(c("Treatment-1", "Treatment-2") %in% input$T1_filter) == TRUE) 
{Venn1.plot <- venn.diagram(x= list(A= A(), B= B(), C= C(), D= D()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 1", "Down regulated 1", "Up regulated 2", "Down regulated 2"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}

else if(all(c("Treatment-2", "Treatment-3") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= C(), B= D(), C= E(), D= G()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 2", "Down regulated 2", "Up regulated 3", "Down regulated 3"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}  

else if(all(c("Treatment-2", "Treatment-4") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= C(), B= D(), C= H(), D= I()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 2", "Down regulated 2", "Up regulated 4", "Down regulated 4"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}    

else if(all(c("Treatment-3", "Treatment-4") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= E(), B= G(), C= H(), D= I()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 3", "Down regulated 3", "Up regulated 4", "Down regulated 4"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}    
    

else if(all(c("Treatment-1", "Treatment-3") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= A(), B= B(), C= E(), D= G()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 1", "Down regulated 1", "Up regulated 2", "Down regulated 2"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}


else if(all(c("Treatment-1", "Treatment-4") %in% input$T1_filter) == TRUE)
{Venn1.plot <- venn.diagram(x= list(A= A(), B= B(), C= H(), D= I()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 1", "Down regulated 1", "Up regulated 2", "Down regulated 2"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")}


})


VENN_plot_2 <- reactive({

if(all(c("Treatment-1", "Treatment-2") %in% input$T1_filter) == TRUE){
Venn2.plot <-venn.diagram(x= list(A= A_1(), B= A_2()), fill = c("red", "blue"), cex = 2, cat.cex = 1.5, sub.cex = 5, main.cex = 2,  category.names = c("Treatment-1", "Treatment-2"), height = 4000, width = 6000, scale = TRUE, main = input$text2, resolution = 500, units = "cm", filename = NULL)
}

else if(all(c("Treatment-1", "Treatment-3") %in% input$T1_filter) == TRUE){
Venn2.plot <- venn.diagram(x= list(A= A_1(), B= A_2(), C= A_3()), fill = c("red", "blue", "green"), cex = 2, cat.cex = 1.5, sub.cex = 5, main.cex = 2,  category.names = c("Treatment-1", "Treatment-2", "Treatment-3"), height = 4000, width = 6000, scale = TRUE, main = input$text2, resolution = 500, units = "cm", filename = NULL)
}

else if (all(c("Treatment-1", "Treatment-4") %in% input$T1_filter) == TRUE){
Venn2.plot <- venn.diagram(x= list(A= A_1(), B= A_2(), C= A_3(), D= A_4()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, main.cex = 2, category.names = c("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"), height = 4000, width = 6000, scale = TRUE, main = input$text2, resolution = 500, units = "cm", filename = NULL)
}
  
})


Venn_draw_1 <- reactive({

if(input$checkbox_2 == "Split into Up and Down-regulated"){VENN_plot_1()}
else if(input$checkbox_2 == "VennDiagram"){VENN_plot_2()}
})

output$Venn_Plot1 <- renderPlot({
  
validate(need(input$T1_filter != "" , "Please select the treatments in pairs to construct the split venn diagram!"),
need(input$checkbox_2 != "", "Please select the choice of venn diagram!")
) 

withProgress(message = "Constructing venn diagram", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
grid::grid.draw(Venn_draw_1())
})
plotOutput("Venn_Plot1")

```

### Histogram
```{r, echo= FALSE}

all_histo_1 <- reactive({
A_1 <- as.data.frame(A())
df_histo_1 <- data.frame(logFC = nrow(A_1), regulation = "Up") %>% add_column(Treatments = "Treatment-1")
B_1 <- as.data.frame(B())
df_histo_1_1 <- data.frame(logFC = nrow(B_1), regulation = "Down") %>% add_column(Treatments = "Treatment-1")

rbind.data.frame(df_histo_1, df_histo_1_1)
})


all_histo_2 <- reactive({
C_1 <- as.data.frame(C())
df_histo_2 <- data.frame(logFC = nrow(C_1), regulation = "Up") %>% add_column(Treatments = "Treatment-2")
D_1 <- as.data.frame(D())
df_histo_2_2 <- data.frame(logFC = nrow(D_1), regulation = "Down") %>% add_column(Treatments = "Treatment-2")

rbind.data.frame(as.data.frame(all_histo_1()), df_histo_2, df_histo_2_2)
})

all_histo_3 <- reactive({
E_1 <- as.data.frame(E())
df_histo_3 <- data.frame(logFC = nrow(E_1), regulation = "Up") %>% add_column(Treatments = "Treatment-3")
G_1 <- as.data.frame(G())
df_histo_3_3 <- data.frame(logFC = nrow(G_1), regulation = "Down") %>% add_column(Treatments = "Treatment-3")

rbind.data.frame(as.data.frame(all_histo_2()), df_histo_3, df_histo_3_3)
})


all_histo_4 <- reactive({  
H_1 <- as.data.frame(H())
df_histo_4 <- data.frame(logFC = nrow(H_1), regulation = "Up") %>% add_column(Treatments = "Treatment-4")
I_1 <- as.data.frame(I())
df_histo_4_4 <- data.frame(logFC = nrow(I_1), regulation = "Down") %>% add_column(Treatments = "Treatment-4")

rbind.data.frame(as.data.frame(all_histo_3()), df_histo_4, df_histo_4_4)
})

Histogram_plot_1 <- reactive({

if (input$T1_filter == "Treatment-1")
{H_plot1 <- ggplot(df_3(), aes(x = logFC))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3()[, 2]), max(df_3()[, 2]), by = 2), 1)) + scale_y_continuous() + theme_bw()+ theme(text = element_text(size=20))}

else if (input$T1_filter == "Treatment-2")
{H_plot2 <- ggplot(df_4(), aes(x = logFC.1))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3()[, 2]), max(df_3()[, 2]), by = 2), 1)) + scale_y_continuous() + theme_bw()+ xlab("logFC")+ theme(text = element_text(size=20))}

else if (input$T1_filter == "Treatment-3")
{H_plot3 <- ggplot(df_5(), aes(x = logFC.2))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3()[, 2]), max(df_3()[, 2]), by = 2), 1)) + scale_y_continuous() + theme_bw()+ xlab("logFC")+ theme(text = element_text(size=20))} 

else if (input$T1_filter == "Treatment-4")
{H_plot4 <- ggplot(df_6(), aes(x = logFC.3))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3()[, 2]), max(df_3()[, 2]), by = 2), 1)) + scale_y_continuous() + theme_bw() + xlab("logFC")+ theme(text = element_text(size=20))}
})


Histogram_plot_all <-  reactive({
  
observeEvent(input$checkbox_3 == "All Treatments", {
  showNotification("Please select upto treatments you want to generate histogram", type = "message", duration = 10)
})  

if(input$T1_filter == "Treatment-1"){H_plot1 <- ggplot(all_histo_1(), aes(x= all_histo_1()[, 1], y= all_histo_1()[, 3], fill= all_histo_1()[, 2] )) + geom_bar(stat="identity", position= "dodge") + ggtitle(input$text2) + theme_bw() + xlab("Number of genes") + ylab("") + geom_text(aes(label=all_histo_1()[, 1]), color="Black", position = position_dodge(0.9), size= 6) + theme(text = element_text(size=20))+ labs(fill = "regulation")
}

else if(input$T1_filter == "Treatment-2"){H_plot2 <- ggplot(all_histo_2(), aes(x= all_histo_2()[, 1], y= all_histo_2()[, 3], fill= all_histo_2()[, 2] )) + geom_bar(stat="identity", position= "dodge") + ggtitle(input$text2) + theme_bw() + xlab("Number of genes") + ylab("") + geom_text(aes(label=all_histo_2()[, 1]), color="Black", position = position_dodge(0.9), size= 6) + theme(text = element_text(size=20))+ labs(fill = "regulation")
}

else if(input$T1_filter == "Treatment-3"){H_plot3 <- ggplot(all_histo_3(), aes(x= all_histo_3()[, 1], y= all_histo_3()[, 3], fill= all_histo_3()[, 2] )) + geom_bar(stat="identity", position= "dodge") + ggtitle(input$text2) + theme_bw() + xlab("Number of genes") + ylab("") + geom_text(aes(label=all_histo_3()[, 1]), color="Black", position = position_dodge(0.9), size= 6) + theme(text = element_text(size=20))+ labs(fill = "regulation")
}

else if(input$T1_filter == "Treatment-4"){H_plot4 <- ggplot(all_histo_4(), aes(x= all_histo_4()[, 1], y= all_histo_4()[, 3], fill= all_histo_4()[, 2] )) + geom_bar(stat="identity", position= "dodge") + ggtitle(input$text2) + theme_bw() + xlab("Number of genes") + ylab("") + geom_text(aes(label=all_histo_4()[, 1]), color="Black", position = position_dodge(0.9), size= 6) + theme(text = element_text(size=20))+ labs(fill = "regulation")
}

})


output$Hist_plot1 <- renderPlot({

validate(

need(input$T1_filter != "" , "Please select the treatments to construct the histogram!"),

need(input$checkbox_3 != "", "Please select the choice of histogram required!")
)  


if(input$checkbox_3 == "Treatment"){

withProgress(message = "Constructing histogram for only one treatment.", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Histogram_plot_1())}

else if (input$checkbox_3 == "All Treatments"){
  
withProgress(message = "Constructing histogram upto selected treatments.", detail = "One treatment is selected at a time!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Histogram_plot_all())}
})

plotOutput("Hist_plot1")


output$Downloadplot_1 <- downloadHandler(
filename =function(){paste("Venn Diagram", tolower(input$select_format), sep = ".")
},

content = function(file){
if (input$select_format == "jpeg")
{jpeg(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "png")
{png(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "pdf")
{pdf(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "tiff")
{tiff(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
}
)


output$Downloadplot_2 <- downloadHandler(
filename =function(){paste("Histogram", tolower(input$select_format), sep = ".")
},

content = function(file){
if(input$checkbox_3 == "Treatment"){ggsave(file, plot(Histogram_plot_1()), device = tolower(input$select_format), width = input$Download_input1, height = input$Download_input2, dpi = input$Download_input3, units = "cm")}

else if(input$checkbox_3 == "All Treatments"){ggsave(file, plot(Histogram_plot_all()), device = tolower(input$select_format), width = input$Download_input1, height = input$Download_input2, dpi = input$Download_input3, units = "cm")}

}
)
```

GO enrichment analysis
=============================================
Sidebar {.sidebar data-width=350}
---------------------------------------------
```{r, echo= FALSE}

checkboxGroupInput(inputId = "select_GO", label = h5(strong("Gene ontology classes")), choices = list("GO Biological Process" = 1, "GO Molecular Function" = 2, "GO Cellular Component"= 3), inline = FALSE)

div(style = "display: inline-block; width: 150px;", numericInput(inputId = "cutoff",  label = h6("p-value cutoff"), value = 0, min = 0, max = 20, step = 0.01 , width = '100%'))

div(style = "display: inline-block; width: 150px;",  numericInput(inputId = "qcutoff",  label = h6("q-value cutoff ORA"), value = 0, min = 0, max = 20, step = 0.01, width = '100%'))

selectInput(inputId = "pA_method", label = h5(strong("pAdjust Method")), choices = c("None" =1, "holm" = 2, "hochberg"= 3, "hommel"= 4, "bonferroni"= 5, "Benjamini & Hochberg(BH)" = 6, "Benjamini & Yekutieli(BY)" = 7, "fdr" = 8 ))

checkboxGroupInput(inputId = "checkbox_GSE_GO", label = h5(strong("Enrichment analysis method")), choices = list("GO ORA",  "GO GSEA"), inline = TRUE)

actionButton(inputId = "submit_GO", "Go!")

checkboxGroupInput(inputId = "heatmapT1_table", label = h5(strong("Download GO result")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"),inline = TRUE)

downloadButton(inputId = "GO_result", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")


downloadHandler(
filename = function(){
if (input$heatmapT1_table == "Treatment-1")
{paste("GO result treatment1", ".csv", sep = "")}
else if (input$heatmapT1_table == "Treatment-2")
{paste("GO result treatment2", ".csv", sep = "")}
else if (input$heatmapT1_table == "Treatment-3")
{paste("GO result treatment3", ".csv",  sep = "")}
else if (input$heatmapT1_table == "Treatment-4")
{paste("GO result treatment4", ".csv",  sep = "")}
},
content = function(file){
if (input$heatmapT1_table == "Treatment-1") {
write.csv(GO_final_table_1(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-2"){
write.csv(GO_final_table_2(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-3") {
write.csv(GO_final_table_3(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-4") {
write.csv(GO_final_table_4(), file, row.names = FALSE)
}
})


```

Column {.tabset}
------------------------------------------------------
### Ontology result-1
```{r, echo= FALSE}
onto_1 <- reactive({
if (input$select_GO == 1) {ontology_1 <- "BP"} 
else if (input$select_GO == 2) {ontology_1 <- "MF"}
else if (input$select_GO == 3) {ontology_1 <- "CC"}
})

Org_database_1 <- reactive({
if (input$select1 == 1) {org.Hs.eg.db} 
else if (input$select1 == 2) {org.Gg.eg.db}
else if (input$select1 == 3) {org.Ss.eg.db}
else if (input$select1 == 4) {org.Bt.eg.db}
})

adjust_method_1 <- reactive({
if (input$pA_method == 1) { PAdjust <- "none"}
else if (input$pA_method == 2) {PAdjust <-"holm"} 
else if (input$pA_method == 3) {PAdjust <-"hochberg"} 
else if (input$pA_method == 4) {PAdjust <-"hommel"} 
else if (input$pA_method == 5) {PAdjust <-"bonferroni"} 
else if (input$pA_method == 6) {PAdjust <-"BH"} 
else if (input$pA_method == 7) {PAdjust <-"BY"} 
else if (input$pA_method == 8) {PAdjust <-"fdr"} 

})

GO_table_001 <- reactive({
df_with_Etzgene <- getBM(attributes = c("entrezgene_id", 'ensembl_gene_id', "external_gene_name"), filters = "ensembl_gene_id",  values = datasetInput(), mart = data_list_1())
})

GO_table_1 <- reactive({
if (input$checkbox_GSE_GO == "GO ORA"){
df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

clusterProfiler::enrichGO(gene = as.vector(GO_merge$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1) }
 
})


#for gene set enrichment ontology treatment 1

GO_gse_table_1 <- reactive({
if (input$checkbox_GSE_GO == "GO GSEA"){
df_3 <- as.data.frame(Filtertable1())  
df_3 <- df_3[, c(1, 2)]

GSEgo_list <- df_3[, 2]

names(GSEgo_list) <- as.character(df_3[, 1])

GSEgo_list <- sort(GSEgo_list, decreasing = TRUE)

clusterProfiler::gseGO(geneList = GSEgo_list, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "ENSEMBL", by = "fgsea") }    

})

GO_final_table_1 <- eventReactive(input$submit_GO, {

withProgress(message = "Fetching gene ontology terms from database for treatment-1", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}

GO_001 <- isolate(if (input$checkbox_GSE_GO == "GO GSEA"){

as.data.frame(GO_gse_table_1()@result)}

else if (input$checkbox_GSE_GO == "GO ORA"){
 as.data.frame(GO_table_1()@result)}
)
GO_001
})

})


output$GO_table_GO <- DT::renderDataTable({

validate(need(input$select_GO != "", "Please select gene ontology term to perform gene ontology enrichment analysis."),

need(input$checkbox_GSE_GO != "", "Please select enrichment method for gene ontology analysis."),

need(input$submit_GO != "", "Please select submit button to perform gene ontology enrichment analysis!")
)

GO_final_table_1()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))

DT::dataTableOutput("GO_table_GO")



###data modification for heatmap

heatmap_plot_data <- reactive({
Selected_data <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(GO_table_1()@result)


selected_rows <- reactive({

GO_rows <- input$GO_table_GO_rows_selected
Selected_data_1[sort(GO_rows), ]
})


Heatmap_data <- as.data.frame(selected_rows())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data[, c(2, 8)]


#separate gene id by /
GO_separated_gene <- separate_rows(Heat_data_1, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

H_data_filtered <- as.data.frame(Filtertable1())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- H_data_filtered[, c(1, 2)]

#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge <- HTmap_merge[, c(2,4)]

h_1_heatmap <- inner_join(x = GO_separated_gene, y = new_h1_heat_merge, by = c("geneID" ="external_gene_name")) %>% unique()
})


#data preparation for gsea heatmap

heatmap_plot_data_gsea <- reactive({

#all uploded file data with different ids  
Selected_data_gse <- as.data.frame(GO_table_001()) 
Selected_data_1_gse <- as.data.frame(GO_gse_table_1()@result)


selected_rows_gse_1 <- reactive({
GO_rows <- input$GO_table_GO_rows_selected
Selected_data_1_gse[sort(GO_rows), ]
})


Heatmap_data_gse <- as.data.frame(selected_rows_gse_1())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data_gse[, c(2, 11)]


#separate gene id by /
GO_separated_gene_gse <- separate_rows(Heat_data_1, "core_enrichment", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

H_data_filtered <- as.data.frame(Filtertable1())


'this dataframe can be used for the conversion of first column to gene name (ensembl and logfc from filtered data'

Heat_data_2 <- H_data_filtered[, c(1, 2)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]

h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by = c("core_enrichment" ="ENSEMBLGENE")) %>% unique()

h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)] 

})

```

### Ontology result-2
```{r, echo= FALSE}

GO_table_2 <-  reactive({

if (input$checkbox_GSE_GO == "GO ORA"){  

df_4 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_2 <- merge(df_4, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

GO_output_result_1 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_2$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff, pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)}

})

#for gene set enrichment ontology treatment 2

GO_gse_table_2 <- reactive({

if (input$checkbox_GSE_GO == "GO GSEA"){ 

df_4 <- as.data.frame(Filtertable2())  
df_4 <- df_4[, c(1, 2)]

GSEgo_list_2 <- df_4[, 2]

names(GSEgo_list_2) <- as.character(df_4[, 1])

GSEgo_list_2 <- sort(GSEgo_list_2, decreasing = TRUE)

GO_output_result_gse_go_2 <- clusterProfiler::gseGO(geneList = GSEgo_list_2, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "ENSEMBL", by = "fgsea")}
})



GO_final_table_2 <- eventReactive(input$submit_GO,{

withProgress(message = "Fetching gene ontology terms from database for treatment-2", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}

GO_002 <- isolate(if (input$checkbox_GSE_GO == "GO ORA"){

as.data.frame(GO_table_2()@result)}

else if (input$checkbox_GSE_GO == "GO GSEA"){
as.data.frame(GO_gse_table_2()@result)}
)
GO_002
})
})


output$GO_table_GO_2 <- DT::renderDataTable({

validate(

need(input$select_GO != "", "Please select gene ontology term to perform gene ontology enrichment analysis."),

need(input$checkbox_GSE_GO != "", "Please select enrichment method for gene ontology analysis!"))  


GO_final_table_2()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))

DT::dataTableOutput("GO_table_GO_2")



#heatmap data preparation for ORA

heatmap_plot_data_2 <- reactive({
Selected_data <- as.data.frame(GO_table_001())
Selected_data_2 <- as.data.frame(GO_table_2()@result)

selected_rows_2 <- reactive({GO_rows <- input$GO_table_GO_2_rows_selected
Selected_data_2[sort(GO_rows), ]})


Heatmap_data_2 <- as.data.frame(selected_rows_2())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_2 <- Heatmap_data_2[, c(2, 8)]


#separate gene id by /
GO_separated_gene_2 <- separate_rows(Heat_data_2, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

H_data_filtered_2 <- as.data.frame(Filtertable2())

'this dataframe can be used for the conversion of first column to gene name'

Heat_data_3 <- H_data_filtered_2[, c(1, 2)]


HTmap_merge_2 <- merge(x = Heat_data_3, y = Selected_data, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_2 <- HTmap_merge_2[, c(2,4)]

h_1_heatmap_2 <- inner_join(x = GO_separated_gene_2, y = new_h1_heat_merge_2, by = c("geneID" ="external_gene_name")) %>% unique()
})



#data preparation for gsea heatmap treatment 2

heatmap_plot_data_gsea_2 <- reactive({

#all uploded file data with different ids  
Selected_data_gse <- as.data.frame(GO_table_001()) 
Selected_data_2_gse <- as.data.frame(GO_gse_table_2()@result)


selected_rows_gse_2 <- reactive({
GO_rows <- input$GO_table_GO_2_rows_selected
Selected_data_2_gse[sort(GO_rows), ]
})


Heatmap_data_gse <- as.data.frame(selected_rows_gse_2())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data_gse[, c(2, 11)]


#separate gene id by /
GO_separated_gene_gse <- separate_rows(Heat_data_1, "core_enrichment", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

H_data_filtered <- as.data.frame(Filtertable1())


'this dataframe can be used for the conversion of first column to gene name (ensembl and logfc from filtered data'

Heat_data_2 <- H_data_filtered[, c(1, 2)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]

h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by = c("core_enrichment" ="ENSEMBLGENE")) %>% unique()

h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)] 

})


```

### Ontology result-3
```{r, echo= FALSE}

#for ORA GO production
GO_table_3 <-  reactive({

if (input$checkbox_GSE_GO == "GO ORA"){  

df_5 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_3 <- merge(df_5, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

GO_output_result_1 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_3$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)}

})



#for gene set enrichment ontology treatment 3

GO_gse_table_3 <- reactive({

if (input$checkbox_GSE_GO == "GO GSEA"){

df_5 <- as.data.frame(Filtertable3())  
df_5 <- df_5[, c(1, 2)]

GSEgo_list_3 <- df_5[, 2]

names(GSEgo_list_3) <- as.character(df_5[, 1])

GSEgo_list_3 <- sort(GSEgo_list_3, decreasing = TRUE)

GO_output_result_gse_go_3 <- clusterProfiler::gseGO(geneList = GSEgo_list_3, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "ENSEMBL", by = "fgsea")}

})

GO_final_table_3 <- eventReactive(input$submit_GO,{

withProgress(message = "Fetching gene ontology terms from database for treatment-3", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}

GO_003 <- isolate(if (input$checkbox_GSE_GO == "GO ORA"){

as.data.frame(GO_table_3()@result)}

else if (input$checkbox_GSE_GO == "GO GSEA"){
as.data.frame(GO_gse_table_3()@result)}
)

GO_003
})
})

output$GO_table_GO_3 <- DT::renderDataTable({

validate(

need(input$select_GO != "", "Please select gene ontology term to perform gene ontology enrichment analysis."),

need(input$checkbox_GSE_GO != "", "Please select enrichment method for gene ontology analysis."))  

GO_final_table_3()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))

DT::dataTableOutput("GO_table_GO_3")


#heatmap data preparation for ORA
heatmap_plot_data_3 <- reactive({
Selected_data <- as.data.frame(GO_table_001())
Selected_data_3 <- as.data.frame(GO_table_3()@result)


selected_rows_3 <- reactive({GO_rows <- input$GO_table_GO_3_rows_selected
Selected_data_3[sort(GO_rows), ]})


Heatmap_data_3 <- as.data.frame(selected_rows_3())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_3 <- Heatmap_data_3[, c(2, 8)]


#separate gene id by /
GO_separated_gene_3 <- separate_rows(Heat_data_3, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

H_data_filtered_3 <- as.data.frame(Filtertable3())

'this dataframe can be used for the conversion of first column to gene name'

Heat_data_4 <- H_data_filtered_3[, c(1, 2)]

HTmap_merge_3 <- merge(x = Heat_data_4, y = Selected_data, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_3 <- HTmap_merge_3[, c(2,4)]

h_1_heatmap_3 <- inner_join(x = GO_separated_gene_3, y = new_h1_heat_merge_3, by = c("geneID" ="external_gene_name")) %>% unique()
})



#data preparation for gsea heatmap treatment 3

heatmap_plot_data_gsea_3 <- reactive({

#all uploded file data with different ids  
Selected_data_gse <- as.data.frame(GO_table_001()) 
Selected_data_3_gse <- as.data.frame(GO_gse_table_3()@result)


selected_rows_gse_3 <- reactive({
GO_rows <- input$GO_table_GO_3_rows_selected
Selected_data_3_gse[sort(GO_rows), ]
})


Heatmap_data_gse <- as.data.frame(selected_rows_gse_3())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data_gse[, c(2, 11)]


#separate gene id by /
GO_separated_gene_gse <- separate_rows(Heat_data_1, "core_enrichment", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

H_data_filtered <- as.data.frame(Filtertable3())


'this dataframe can be used for the conversion of first column to gene name (ensembl and logfc from filtered data'

Heat_data_2 <- H_data_filtered[, c(1, 2)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]

h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by = c("core_enrichment" ="ENSEMBLGENE")) %>% unique()

h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)] 

})


```

### Ontology result-4
```{r, echo= FALSE}

GO_table_4 <- reactive({

if (input$checkbox_GSE_GO == "GO ORA"){    

df_6 <- as.data.frame(Filtertable4())

df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_4 <- merge(df_6, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

GO_output_result_1 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_4$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)}

})



#for gene set enrichment ontology treatment 4

GO_gse_table_4 <- reactive({

if (input$checkbox_GSE_GO == "GO GSEA"){  

df_6 <- as.data.frame(Filtertable4())  
df_6 <- df_6[, c(1, 2)]

GSEgo_list_4 <- df_6[, 2]

names(GSEgo_list_4) <- as.character(df_6[, 1])

GSEgo_list_4 <- sort(GSEgo_list_4, decreasing = TRUE)

GO_output_result_gse_go_4 <- clusterProfiler::gseGO(geneList = GSEgo_list_4, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "ENSEMBL", by = "fgsea")}

})


GO_final_table_4 <- eventReactive(input$submit_GO, { 

withProgress(message = "Fetching gene ontology terms from database for treatment-4", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}

GO_004 <- isolate(if (input$checkbox_GSE_GO == "GO ORA"){

as.data.frame(GO_table_4()@result)}

else if (input$checkbox_GSE_GO == "GO GSEA"){
as.data.frame(GO_gse_table_4()@result)}
)

GO_004
})

})

output$GO_table_GO_4 <- DT::renderDataTable({

validate(

need(input$select_GO != "", "Please select gene ontology term to perform gene ontology enrichment analysis!"),

need(input$checkbox_GSE_GO != "", "Please select enrichment method for gene ontology analysis."))



GO_final_table_4()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))

DT::dataTableOutput("GO_table_GO_4")



#data preparation for heatmap ora4
heatmap_plot_data_4 <- reactive({
  
Selected_data <- as.data.frame(GO_table_001())
Selected_data_4 <- as.data.frame(GO_table_4()@result)

selected_rows_4 <- reactive({GO_rows <- input$GO_table_GO_4_rows_selected
Selected_data_4[sort(GO_rows), ]})


Heatmap_data_4 <- as.data.frame(selected_rows_4())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_4 <- Heatmap_data_4[, c(2, 8)]


#separate gene id by /
GO_separated_gene_4 <- separate_rows(Heat_data_4, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

H_data_filtered_4 <- as.data.frame(Filtertable4())

'this dataframe can be used for the conversion of first column to gene name'

Heat_data_5 <- H_data_filtered_4[, c(1, 2)]

HTmap_merge_4 <- merge(x = Heat_data_5, y = Selected_data, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_4 <- HTmap_merge_4[, c(2,4)]

h_1_heatmap_4 <- inner_join(x = GO_separated_gene_4, y = new_h1_heat_merge_4, by = c("geneID" ="external_gene_name")) %>% unique()
})



#data preparation for gsea heatmap treatment 4

heatmap_plot_data_gsea_4 <- reactive({


#all uploded file data with different ids  
Selected_data_gse <- as.data.frame(GO_table_001()) 
Selected_data_4_gse <- as.data.frame(GO_gse_table_4()@result)


selected_rows_gse_2 <- reactive({
GO_rows <- input$GO_table_GO_4_rows_selected
Selected_data_4_gse[sort(GO_rows), ]
})


Heatmap_data_gse <- as.data.frame(selected_rows_gse_2())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data_gse[, c(2, 11)]


#separate gene id by /
GO_separated_gene_gse <- separate_rows(Heat_data_1, "core_enrichment", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

H_data_filtered <- as.data.frame(Filtertable4())


'this dataframe can be used for the conversion of first column to gene name (ensembl and logfc from filtered data'

Heat_data_2 <- H_data_filtered[, c(1, 2)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]

h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by = c("core_enrichment" ="ENSEMBLGENE")) %>% unique()

h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)] 

})


output$GO_result <- downloadHandler(
filename = function(){
if (input$heatmapT1_table == "Treatment-1")
{paste("GO result treatment1", Sys.Date(), ".csv", sep = "")}
else if (input$heatmapT1_table == "Treatment-2")
{paste("GO result treatment2", Sys.Date(), ".csv", sep = "")}
else if (input$heatmapT1_table == "Treatment-3")
{paste("GO result treatment3", Sys.Date(), ".csv",  sep = "")}
else if (input$heatmapT1_table == "Treatment-4")
{paste("GO result treatment4", Sys.Date(), ".csv",  sep = "")}
},
content = function(file){
if (input$heatmapT1_table == "Treatment-1") {
write.csv(GO_final_table_1(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-2"){
write.csv(GO_final_table_2(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-3") {
write.csv(GO_final_table_3(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-4") {
write.csv(GO_final_table_4(), file, row.names = FALSE)
}
})

```

GO heatmaps
========================================
Sidebar {.sidebar data-width=350}
----------------------------------------
```{r, echo=FALSE}

checkboxGroupInput(inputId = "checkbox_heatmap_GO", label = h5(strong("Heatmap visualization")), choices = list("GO ORA",  "GO GSEA"), inline = TRUE)

checkboxGroupInput(inputId = "heatmapT1", label = h5(strong("Treatments")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"),inline = TRUE)

fluidRow(column(4, numericInput( inputId = "heatmap_input1",  label = h6("col text size"), value = 1.2, min = 0.1, max = 10, step = 0.1, width = '100%')),
column (4, numericInput( inputId = "heatmap_input2",  label = h6("row text size"), value = 1.2, min = 0.1, max = 10, step = 0.1, width = '100%')),
column (4, numericInput( inputId = "heatmap_input3",  label = h6("color key size"), value = 0.4, min = 0.1, max = 10, step = 0.1, width = '100%')))

textInput(inputId = "heat_text", label = h5(strong("Title for heatmap")), value = "")

selectInput(inputId = "select_format_GO", label = h5(strong("Format")), choices = c("jpeg", "png", "pdf", "tiff"))

fluidRow(column (4, numericInput( inputId = "Download_heat_input1",  label = h6("Plot width"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_heat_input2",  label = h6("Plot height"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_heat_input3",  label = h6("Plot resolution"), value = 300, min = 10, max = 500, step = 50, width = '100%')))

downloadButton(inputId = "Download_heat_map", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")


downloadHandler(
filename = function(){paste0("heatmap", sep = ".", input$select_format_GO)},

content = function(file){
if (input$select_format_GO == "jpeg"){
jpeg(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}

else if (input$select_format_GO == "png"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}

else if (input$select_format_GO == "pdf"){
pdf(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}
  
else if (input$select_format_GO == "tiff"){
tiff(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}  

  
})

h5(strong("Visualization of Ontology"))
fluidRow(column(4,checkboxGroupInput(inputId = "checkbox_4", label = "", choices = list("Word Cloud"), inline = TRUE)),
column(4,numericInput( inputId = "wordcloud_input1",  label = h6("max.words"), value = 100, min = 10, max = 500, step = 50, width = '100%')))
                
downloadButton(inputId = "downloadwordcloud", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")


downloadHandler(
filename = function(){paste0("wordcloud", sep=".", input$select_format_GO)
},
content = function(file){
if (input$select_format_GO == "jpeg"){
jpeg(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}

else if (input$select_format_GO == "png"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}

else if (input$select_format_GO == "pdf"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}
  
else if (input$select_format_GO == "tiff"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}  
  
})

```

Column {.tabset}
-------------------------------------------
### Heatmaps
```{r, echo=FALSE}

# these code for GSEA heatmap
heatmap_gse_1 <- reactive({

if(input$checkbox_heatmap_GO == "GO GSEA"){

h_plot_data_gse_1 <- as.data.frame(heatmap_plot_data_gsea())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(2, 3)]

names(h_plot_gse_1_1)[2] <- as.character(h_plot_data_gse_1[[1, 1]])

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
}
})


heatmap_gse_12 <- reactive({

if (input$checkbox_heatmap_GO == "GO GSEA"){  

h_plot_data_gse_2 <- as.data.frame(heatmap_plot_data_gsea_2())

h_plot_gse_2_2 <- h_plot_data_gse_2[, c(2, 3)]

names(h_plot_gse_2_2)[2] <- as.character(h_plot_data_gse_2[[1, 1]])

heatmap_f1 <- merge(heatmap_gse_1(), h_plot_gse_2_2, by.y = "external_gene_name", by.x = "external_gene_name", all = TRUE, suffixes = c("", ""))

heatmap_f4 <- as.data.frame(replace(heatmap_f1, is.na(heatmap_f1), 0))

}
})

heatmap_gse_13 <- reactive({

if (input$checkbox_heatmap_GO == "GO GSEA"){   

h_plot_data_gse_2 <- as.data.frame(heatmap_plot_data_gsea_3())

h_plot_gse_2_2 <- h_plot_data_gse_2[, c(2, 3)]

names(h_plot_gse_2_2)[2] <- as.character(h_plot_data_gse_2[[1, 1]])

heatmap_f1 <- merge(heatmap_gse_12(), h_plot_gse_2_2, by.y = "external_gene_name", by.x = "external_gene_name", all = TRUE, suffixes = c("", ""))

heatmap_f4 <- as.data.frame(replace(heatmap_f1, is.na(heatmap_f1), 0))

}
})


heatmap_gse_14 <- reactive({

if (input$checkbox_heatmap_GO == "GO GSEA"){  

h_plot_data_gse_2 <- as.data.frame(heatmap_plot_data_gsea_4())

h_plot_gse_2_2 <- h_plot_data_gse_2[, c(2, 3)]

names(h_plot_gse_2_2)[2] <- as.character(h_plot_data_gse_2[[1, 1]])

heatmap_f1 <- merge(heatmap_gse_13(), h_plot_gse_2_2, by.y = "external_gene_name", by.x = "external_gene_name", all = TRUE, suffixes = c("", ""))

heatmap_f4 <- as.data.frame(replace(heatmap_f1, is.na(heatmap_f1), 0))

}
})


heatmap_11 <- reactive({
if (all(c("Treatment-1", "Treatment-2") %in% input$heatmapT1)){

heatmap_f3 <- as.data.frame(heatmap_gse_12()) 
heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "external_gene_name")

heatmap_22 <- as.matrix(heatmap_f5)

rlm <- rainbow(ncol(heatmap_22))

heatmap.2(heatmap_22, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none",  margins = c(3,22), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,) 
legend("topright", legend = c("Treatment-1", "Treatment-2"), col = rlm, lty= 1,lwd = 8,bty = "n")
}


if (all(c("Treatment-1", "Treatment-3") %in% input$heatmapT1)){

heatmap_f3 <- as.data.frame(heatmap_gse_13()) 
heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "external_gene_name")

heatmap_22 <- as.matrix(heatmap_f5)

rlm <- rainbow(ncol(heatmap_22))

heatmap.2(heatmap_22, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none",  margins = c(3,22), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,) 
legend("topright", legend = c("Treatment-1", "Treatment-2", "Treatment-3"), col = rlm, lty= 1,lwd = 8,bty = "n")
}


if (all(c("Treatment-1", "Treatment-4") %in% input$heatmapT1)){

heatmap_f3 <- as.data.frame(heatmap_gse_14()) 
heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "external_gene_name")

heatmap_22 <- as.matrix(heatmap_f5)

rlm <- rainbow(ncol(heatmap_22))

heatmap.2(heatmap_22, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none",  margins = c(3,22), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,) 
legend("topright", legend = c("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"), col = rlm, lty= 1,lwd = 8,bty = "n")

}

})


heatmap_ora_11 <- reactive({

if (input$checkbox_heatmap_GO == "GO ORA"){  

h_plot_data <- as.data.frame(heatmap_plot_data())

h_plot_data_1_1 <- h_plot_data[, c(2, 3)]

names(h_plot_data_1_1)[2] <- as.character(h_plot_data[[1, 1]])

heatmap_f_try <- as.data.frame(replace(h_plot_data_1_1, is.na(h_plot_data_1_1), 0))

}
})

heatmap_ora_12 <- reactive({

if (input$checkbox_heatmap_GO == "GO ORA"){

h_plot_data_2 <- as.data.frame(heatmap_plot_data_2())

h_plot_data_2_2 <- h_plot_data_2[, c(2, 3)]

names(h_plot_data_2_2)[2] <- as.character(h_plot_data_2[[1, 1]])

heatmap_f2 <- merge(heatmap_ora_11(), h_plot_data_2_2, by.y = "geneID", by.x = "geneID", all = TRUE, suffixes = c("", ""))

heatmap_f3 <- as.data.frame(replace(heatmap_f2, is.na(heatmap_f2), 0))

}
})


heatmap_ora_13 <- reactive({

if (input$checkbox_heatmap_GO == "GO ORA"){  

h_plot_data_3 <- as.data.frame(heatmap_plot_data_3())

h_plot_data_3_3 <- h_plot_data_3[, c(2, 3)]

names(h_plot_data_3_3)[2] <- as.character(h_plot_data_3[[1, 1]])

heatmap_f2 <- merge(heatmap_ora_12(), h_plot_data_3_3, by.y = "geneID", by.x = "geneID", all = TRUE, suffixes = c("", ""))

heatmap_f3 <- as.data.frame(replace(heatmap_f2, is.na(heatmap_f2), 0))

}
})


heatmap_ora_14 <- reactive({

if (input$checkbox_heatmap_GO == "GO ORA"){  

h_plot_data_4 <- as.data.frame(heatmap_plot_data_4())

h_plot_data_4_4 <- h_plot_data_4[, c(2, 3)]

names(h_plot_data_4_4)[2] <- as.character(h_plot_data_4[[1, 1]])

heatmap_f2 <- merge(heatmap_ora_13(), h_plot_data_4_4, by.y = "geneID", by.x = "geneID", all = TRUE, suffixes = c("", ""))

heatmap_f3 <- as.data.frame(replace(heatmap_f2, is.na(heatmap_f2), 0))

}
})


heatmap_12 <- reactive({

if (all(c("Treatment-1", "Treatment-2") %in% input$heatmapT1)){

heatmap_f3 <- as.data.frame(heatmap_ora_12()) 
heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "geneID") %>% unique()

heatmap_ora_1_1 <- as.matrix(heatmap_f5)

rlm <- rainbow(ncol(heatmap_ora_1_1))

heatmap.2(heatmap_ora_1_1, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none", margins = c(3,30), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0) 
legend("topright", legend = c("Treatment-1", "Treatment-2"), col = rlm, lty= 1,lwd = 5, bty = "n")


}


else if (all(c("Treatment-1", "Treatment-3" ) %in% input$heatmapT1)) {

heatmap_f3 <- as.data.frame(heatmap_ora_13())  

heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "geneID")

heatmap_ora_1_1 <- as.matrix(heatmap_f5)

rlm <- rainbow(ncol(heatmap_ora_1_1))

heatmap.2(heatmap_ora_1_1, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none", margins = c(2,20), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,)
legend("topright", legend = c("Treatment-1", "Treatment-2", "Treatment-3"), col = rlm, lty= 1,lwd = 5,bty = "n")
}


else if (all(c("Treatment-1", "Treatment-4" ) %in% input$heatmapT1)) {

heatmap_f3 <- as.data.frame(heatmap_ora_14())

heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "geneID")

heatmap_ora_1_1 <- as.matrix(heatmap_f5)

rlm <- rainbow(ncol(heatmap_ora_1_1))

heatmap.2(heatmap_ora_1_1, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none", margins = c(3,22), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,) 
legend("topright", legend = c("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"), col = rlm, lty= 1,lwd = 8,bty = "n")

}

})


final_heat_map_plot <- reactive({

if (input$checkbox_heatmap_GO == "GO GSEA") {heatmap_11()}

else if (input$checkbox_heatmap_GO == "GO ORA"){heatmap_12()}

p1 <- recordPlot()  
  
})


output$heatmap_16 <- renderPlot({

validate(need(input$checkbox_heatmap_GO != "", "Please select heatmap visualization for heatmap construction."),
need(input$heatmapT1 != "", "Please select the treatment to generate heatmap visualization."))  

if(input$heatmapT1 > 0){
withProgress(message = "Heatmap prodution of Gene ontology",  detail = "Constructing heatmap according to the row selection in GO analysis.", value = 0,
{
for(i in 1:10)
{incProgress(1/15)
 Sys.sleep(0.1)}  

final_heat_map_plot()})
}

})
plotOutput("heatmap_16")

```

### GO word cloud
```{r, echo=FALSE}

GO_word_cloud_ora <- eventReactive(input$checkbox_4, {

if(input$heatmapT1 == "Treatment-1" ){

wordcloud::wordcloud(words = GO_final_table_1()[1:500, 2], freq = GO_final_table_1()[1:500, 9], min.freq = 10, colors = brewer.pal(8, "Dark2"), random.color = FALSE, scale = c(3, 0.4),  max.words = input$wordcloud_input1) }

else if(input$heatmapT1 == "Treatment-2" ){

wordcloud::wordcloud(words = GO_final_table_2()[1:500, 2], freq = GO_final_table_2()[1:500, 9], min.freq = 10, colors = brewer.pal(8, "Dark2"), random.color = FALSE, scale = c(3, 0.4),  max.words = input$wordcloud_input1)}

else if(input$heatmapT1 == "Treatment-3" ){

wordcloud::wordcloud(words = GO_final_table_3()[1:500, 2], freq = GO_final_table_3()[1:500, 9], min.freq = 10, colors = brewer.pal(8, "Dark2"), random.color = FALSE, scale = c(3, 0.4),  max.words = input$wordcloud_input1)}

else if(input$heatmapT1 == "Treatment-4"){

wordcloud::wordcloud(words = GO_final_table_4()[1:500, 2], freq = GO_final_table_4()[1:500, 9], min.freq = 10, colors = brewer.pal(8, "Dark2"), random.color = FALSE, scale = c(3, 0.4),  max.words = input$wordcloud_input1)}

cloud_x <- recordPlot()  
  
})


output$GO_cloud_word <- renderPlot({
  
validate(
need(input$checkbox_heatmap_GO != "", "Please select the type of GO enrichment performed to construct the wordcloud."),
need(input$heatmapT1 != "", "Please select the treatment to construct the wordcloud."),
need(input$checkbox_4 != "", "Please select the wordcloud option to construct the wordcloud."))
    
  
GO_word_cloud_ora()})

plotOutput("GO_cloud_word", width = "100%", height = 700)


#downloadhandler for cloud
output$downloadwordcloud <- downloadHandler(
filename = function(){paste0("wordcloud", sep=".", input$select_format_GO)
},

content = function(file){
if (input$select_format_GO == "jpeg"){
jpeg(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}

else if (input$select_format_GO == "png"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}

else if (input$select_format_GO == "pdf"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}
  
else if (input$select_format_GO == "tiff"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}  
  
})




#download tab for heatmap

output$Download_heat_map <- downloadHandler(

filename = function(){paste0("heatmap", input$select_format_GO, Sys.Date(), sep = ".")},

content = function(file){
if (input$select_format_GO == "jpeg"){
jpeg(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}

else if (input$select_format_GO == "png"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}

else if (input$select_format_GO == "pdf"){
pdf(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}
  
else if (input$select_format_GO == "tiff"){
tiff(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}  
})

```

Pathway enrichment analysis
========================================
Sidebar {.sidebar data-width=350}
----------------------------------------
```{r, echo= FALSE}
checkboxGroupInput(inputId = "checkbox_KEGG", label = h5(strong("Select Pathway analysis Method")), choices = list("Over-Representation analysis", "Gene Set Enrichment Analysis", "Network Topology Analysis (NTA)", "ReactomePA"), inline = FALSE)

numericInput(inputId = "cutoff_KEGG",  label = h6(strong("p-value cutoff")), value = 0, min = 0, max = 20, step = 0.01)

selectInput(inputId = "pA_method2", label = h5(strong("pAdjust Method")), choices = c("None" =1, "holm" = 2, "hochberg"= 3, "hommel"= 4, "bonferroni"= 5, "Benjamini & Hochberg(BH)" = 6, "Benjamini & Yekutieli(BY)" = 7, "fdr" = 8 ))

selectInput(inputId = "Pathway_database", label = h5(strong("Databases for NTA and Homo Sapiens species only)")), choices = c("biocarta", "panther", "nci", "pharmgkb"))

actionButton(inputId = "submit_KEGG", "Go!")

checkboxGroupInput(inputId = "pathway_T1", label = h5(strong("Pathway enrichment result")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"),inline = TRUE)

downloadButton(inputId = "KEGG_result", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")


downloadHandler(
filename = function(){
if (input$pathway_T1 == "Treatment-1")
{paste("Pathway_result1", ".csv", sep = "")}
else if (input$pathway_T1 == "Treatment-2")
{paste("Pathway_result2",".csv", sep = "")}
else if (input$pathway_T1 == "Treatment-3")
{paste("Pathway_result3", ".csv",  sep = "")}
else if (input$pathway_T1 == "Treatment-4")
{paste("Pathway_result4", ".csv",  sep = "")}
},
content = function(file){
if (input$pathway_T1 == "Treatment-1") {
write.csv(KEGG_final_table_1(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-2"){
write.csv(KEGG_final_table_2(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-3") {
write.csv(KEGG_final_table_3(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-4") {
write.csv(KEGG_final_table_4(), file, row.names = FALSE)
}
})

```

Column {.tabset}
-------------------------------------
### Pathway result-1
```{r, echo= FALSE}

keg_spec_1 <- reactive({
if (input$select1 == 1) {org_kegg_1 <- "hsa" } 
else if (input$select1 == 2) {org_kegg_1 <- "gga"}
else if (input$select1 == 3) {org_kegg_1 <- "ssc" }
else if (input$select1 == 4) {org_kegg_1 <- "bta" }
})


#for SPIA(NTA)
keg_spec_2 <- reactive({
if (input$select1 == 1) {org_kegg_1 <- "hsapiens" } 
else if (input$select1 == 2) {org_kegg_1 <- "ggallus"}
else if (input$select1 == 3) {org_kegg_1 <- "sscrofa" }
else if (input$select1 == 4) {org_kegg_1 <- "btaurus" }
})

#code for ORA KEGG data

KEGG_table_ora_1 <- reactive({

if (input$checkbox_KEGG == "Over-Representation analysis"){

df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

KEGG_output_result <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}

})

#code for GSEA KEGG data

KEGG_table_gse_1 <- reactive({

if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
df_3 <- as.data.frame(Filtertable1())

df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC") 
GO_merge_3 <- GO_merge_2[, "logFC"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)

KEGG_output_result_1 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}
})



#code for reactomePA pathway data

reactome_table_1 <- reactive({

if (input$checkbox_KEGG == "ReactomePA"){

df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

KEGG_output_result <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}
})


#Network topology analysis
network_topology_1 <- reactive({

if (input$checkbox_KEGG == "Network Topology Analysis (NTA)"){
df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id", all = TRUE)

GO_merge_spai <- GO_merge[, c(1, 2,5)]

GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)

GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 2)]

GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]

de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))

de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)

de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)

colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"

de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)

final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)

final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))

names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID


#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]

all_spai_ref <- as.data.frame(all_spai_ref)

all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]

all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))

all_spai_ref_1 <- gsub(" ", "", all_spai_ref)


#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)

result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))

}
})


#final table output of pathway treatment-1

KEGG_final_table_1 <- eventReactive(input$submit_KEGG, {

withProgress(message = "Fetching enriched term from database for treatment-1", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}

KEGG_001 <- isolate(if (input$checkbox_KEGG == "Over-Representation analysis"){

as.data.frame(KEGG_table_ora_1()@result)}

else if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){

as.data.frame(KEGG_table_gse_1()@result)}

else if (input$checkbox_KEGG == "ReactomePA"){

as.data.frame(reactome_table_1()@result)  
}
else if (input$checkbox_KEGG == "Network Topology Analysis (NTA)"){

as.data.frame(network_topology_1())  
}

)
KEGG_001
})

})


#code for selected column in Treatment-1

output$Pathway_table_1 <- DT::renderDataTable({

validate(need(input$checkbox_KEGG != "", "Please select the enrichment method, p-cutoff value and FDR correction method for pathway analysis."),

need(input$submit_KEGG, "Please select action button GO to perform  pathway enrichment analysis."

))
  
observeEvent(input$Pathway_table_4_rows_selected > 0, {
  showNotification("Please select only one row and same enriched pathway in all treatments.", duration = 10, type = "message")
}) 


KEGG_final_table_1()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))

DT::dataTableOutput("Pathway_table_1")



# ORA from this data we build the KEGG pathway

pathway_ora_plot_1 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(KEGG_table_ora_1()@result)


selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_1_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_1())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 8)]

separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable1())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()

})

#pathway selected data for gsea treatment-1

pathway_gsea_plot_1 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(KEGG_table_gse_1()@result)

selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_1_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_1())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 11)]

separated_pathway <- separate_rows(pathway_data_1, "core_enrichment", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable1())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()

})


##########################
##########################
#pathway selected data for reactome treatment-2

pathway_react_plot_1 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(reactome_table_1()@result)

selected_rows_pathway_1 <- reactive({

GO_rows_pathway_1 <- input$Pathway_table_1_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]
})

pathway_data <- as.data.frame(selected_rows_pathway_1())

#columns selected from the reactome pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 8)]

separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable1())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()

})



```

###  Pathway result-2
``` {r, echo= FALSE}

#ORA KEGG DATA 2
KEGG_table_ora_2 <- reactive({

if (input$checkbox_KEGG == "Over-Representation analysis"){

df_3 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_2 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

KEGG_output_result_2 <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge_2$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}

})



#GSEA KEGG data 2
KEGG_table_gse_2 <- reactive({

if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
df_3 <- as.data.frame(Filtertable2())

df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC.1") 
GO_merge_3 <- GO_merge_2[, "logFC.1"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)

KEGG_output_result_2 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}
})



network_topology_2 <- reactive({

if (input$checkbox_KEGG == "Network Topology Analysis (NTA)"){
df_3 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id", all = TRUE)

GO_merge_spai <- GO_merge[, c(1, 2,5)]

GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)

GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 2)]

GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]

de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))

de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)

de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)

colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"

de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)

final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)

final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))

names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID


#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]

all_spai_ref <- as.data.frame(all_spai_ref)

all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]

all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))

all_spai_ref_1 <- gsub(" ", "", all_spai_ref)


#databse preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)

result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))

}
})



#code for reactomePA pathway data 2

reactome_table_2 <- reactive({

if (input$checkbox_KEGG == "ReactomePA"){

df_3 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

KEGG_output_result <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}
})



KEGG_final_table_2 <- eventReactive(input$submit_KEGG,{

withProgress(message = "Fetching enriched term from database for treatment-2", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}

KEGG_002 <- isolate(

if (input$checkbox_KEGG == "Over-Representation analysis"){
as.data.frame(KEGG_table_ora_2()@result)}

else if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
as.data.frame(KEGG_table_gse_2()@result)}

else if (input$checkbox_KEGG == "ReactomePA"){
as.data.frame(reactome_table_2()@result)}

else if (input$checkbox_KEGG == "Network Topology Analysis (NTA)"){
as.data.frame(network_topology_2())}

)

KEGG_002
})

})

output$Pathway_table_2 <- DT::renderDataTable({

validate(need(input$checkbox_KEGG != "", "Please select the enrichment method, p-cutoff value and FDR correction method for pathway analysis."),

need(input$submit_KEGG, "Please select action button GO to perform  pathway enrichment analysis!"

))

KEGG_final_table_2()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))

DT::dataTableOutput("Pathway_table_2")




#selection of rows for pathway treatment-2

pathway_ora_plot_2 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_2 <- as.data.frame(KEGG_table_ora_2()@result)


selected_rows_pathway_2 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_2_rows_selected
Selected_data_2[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_2())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 8)]

separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable2())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()

})


#pathway selected data for gsea treatment-2

pathway_gsea_plot_2 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_2 <- as.data.frame(KEGG_table_gse_2()@result)


selected_rows_pathway_2 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_2_rows_selected
Selected_data_2[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_2())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1, 2, 11)]

separated_pathway <- separate_rows(pathway_data_1, "core_enrichment", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable2())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logFC to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3,4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()

})


##########################
##########################
#pathway selected data for reactome treatment-2

pathway_react_plot_2 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(reactome_table_2()@result)

selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_2_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_1())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 8)]

separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable2())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()

})

```

### Pathway result-3
``` {r, echo= FALSE}

#ORA KEGG DATA 3
KEGG_table_ora_3 <- reactive({

if (input$checkbox_KEGG == "Over-Representation analysis"){

df_3 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_3 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

KEGG_output_result_3 <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge_3$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}

})



#GSEA KEGG data 3
KEGG_table_gse_3 <- reactive({

if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
df_3 <- as.data.frame(Filtertable3())

df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC.2") 
GO_merge_3 <- GO_merge_2[, "logFC.2"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)

KEGG_output_result_3 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}
})



network_topology_3 <- reactive({

if (input$checkbox_KEGG == "Network Topology Analysis (NTA)"){
df_3 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id", all = TRUE)

GO_merge_spai <- GO_merge[, c(1, 2,5)]

GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)

GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 2)]

GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]

de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))

de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)

de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)

colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"

de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)

final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)

final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))

names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID


#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]

all_spai_ref <- as.data.frame(all_spai_ref)

all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]

all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))

all_spai_ref_1 <- gsub(" ", "", all_spai_ref)


#Database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)

result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))

}
})



#Code for reactomePA pathway data 3

reactome_table_3 <- reactive({

if (input$checkbox_KEGG == "ReactomePA"){

df_3 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

KEGG_output_result <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}
})




KEGG_final_table_3 <- eventReactive(input$submit_KEGG,{

withProgress(message = "Fetching enriched term from database for treatment-3", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}

KEGG_003 <- isolate(if (input$checkbox_KEGG == "Over-Representation analysis"){

as.data.frame(KEGG_table_ora_3()@result)}

else if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
as.data.frame(KEGG_table_gse_3()@result)}


else if (input$checkbox_KEGG == "ReactomePA"){
as.data.frame(reactome_table_3()@result)}

else if (input$checkbox_KEGG == "Network Topology Analysis (NTA)"){
as.data.frame(network_topology_3())}

)
KEGG_003
})

})

output$Pathway_table_3 <- DT::renderDataTable({

validate(need(input$checkbox_KEGG != "", "Please select the enrichment method, p-cutoff value and FDR correction method for pathway analysis."),

need(input$submit_KEGG, "Please select action button GO to perform  pathway enrichment analysis!"

))
KEGG_final_table_3()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))

DT::dataTableOutput("Pathway_table_3")


#Selection of rows for pathway treatment-3

pathway_ora_plot_3 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_3 <- as.data.frame(KEGG_table_ora_3()@result)


selected_rows_pathway_3 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_3_rows_selected
Selected_data_3[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_3())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 8)]

separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable3())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()

})


#pathway selected data for gsea treatment-3

pathway_gsea_plot_3 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_3 <- as.data.frame(KEGG_table_gse_3()@result)


selected_rows_pathway_3 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_3_rows_selected
Selected_data_3[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_3())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,11)]

separated_pathway <- separate_rows(pathway_data_1, "core_enrichment", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable3())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logFC to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logFC to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()

})


##########################
##########################
#pathway selected data for reactome treatment-2

pathway_react_plot_3 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(reactome_table_3()@result)

selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_3_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_1())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 8)]

separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable3())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()

})

```

### Pathway result-4
``` {r, echo= FALSE}

#ORA KEGG DATA 4
KEGG_table_ora_4 <- reactive({

if (input$checkbox_KEGG == "Over-Representation analysis"){

df_3 <- as.data.frame(Filtertable4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_4 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

KEGG_output_result_4 <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge_4$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}

})



#GSEA KEGG data 4
KEGG_table_gse_4 <- reactive({

if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
df_3 <- as.data.frame(Filtertable4())

df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC.3") 
GO_merge_3 <- GO_merge_2[, "logFC.3"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)

KEGG_output_result_4 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}
})



network_topology_4 <- reactive({

if (input$checkbox_KEGG == "Network Topology Analysis (NTA)"){
df_3 <- as.data.frame(Filtertable4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id", all = TRUE)

GO_merge_spai <- GO_merge[, c(1, 2,5)]

GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)

GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 2)]

GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]

de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))

de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)

de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)

colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"

de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)

final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)

final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))

names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID


#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]

all_spai_ref <- as.data.frame(all_spai_ref)

all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]

all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))

all_spai_ref_1 <- gsub(" ", "", all_spai_ref)


#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)

result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))

}
})



#code for reactomePA pathway data 4

reactome_table_4 <- reactive({

if (input$checkbox_KEGG == "ReactomePA"){

df_3 <- as.data.frame(Filtertable4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())

GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

KEGG_output_result <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}
})




KEGG_final_table_4 <- eventReactive(input$submit_KEGG,{

withProgress(message = "Fetching enriched term from database for treatment-4", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}

KEGG_004 <- isolate(if (input$checkbox_KEGG == "Over-Representation analysis"){

as.data.frame(KEGG_table_ora_4()@result)}

else if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
as.data.frame(KEGG_table_gse_4()@result)}


else if (input$checkbox_KEGG == "ReactomePA"){
as.data.frame(reactome_table_4()@result)}

else if (input$checkbox_KEGG == "Network Topology Analysis (NTA)"){
as.data.frame(network_topology_4())}

)
KEGG_004
})

})

output$Pathway_table_4 <- DT::renderDataTable({

validate(need(input$checkbox_KEGG != "", "Please select the enrichment method, p-cutoff value and FDR correction method for pathway analysis."),

need(input$submit_KEGG, "Please select action button GO to perform  pathway enrichment analysis!"

))
  
KEGG_final_table_4()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))

DT::dataTableOutput("Pathway_table_4")



#selection of rows for pathway treatment-4
pathway_ora_plot_4 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_4 <- as.data.frame(KEGG_table_ora_4()@result)


selected_rows_pathway_2 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_4_rows_selected
Selected_data_4[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_2())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 8)]

separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable4())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()

})


#pathway selected data for GSEA treatment-4

pathway_gsea_plot_4 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_4 <- as.data.frame(KEGG_table_gse_4()@result)


selected_rows_pathway_4 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_4_rows_selected
Selected_data_4[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_4())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,11)]

separated_pathway <- separate_rows(pathway_data_1, "core_enrichment", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable4())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logFC to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logFC to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()

})



##########################
##########################
#pathway selected data for reactome treatment-2

pathway_react_plot_4 <- reactive({

Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(reactome_table_4()@result)

selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_4_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})

pathway_data <- as.data.frame(selected_rows_pathway_1())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 8)]

separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

P_data_filtered <- as.data.frame(Filtertable4())


'this dataframe can be used for the conversion of first column to gene name'

Heat_data_2 <- P_data_filtered[, c(1, 2)]


#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)


#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]

h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()

})


######################
#Download tab       ##
######################

output$KEGG_result <- downloadHandler(
filename = function(){
if (input$pathway_T1 == "Treatment-1")
{paste("Pathway_result1", ".csv", sep = "")}
else if (input$pathway_T1 == "Treatment-2")
{paste("Pathway_result2",".csv", sep = "")}
else if (input$pathway_T1 == "Treatment-3")
{paste("Pathway_result3", ".csv",  sep = "")}
else if (input$pathway_T1 == "Treatment-4")
{paste("Pathway_result4", ".csv",  sep = "")}
},
content = function(file){
if (input$pathway_T1 == "Treatment-1") {
write.csv(KEGG_final_table_1(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-2"){
write.csv(KEGG_final_table_2(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-3") {
write.csv(KEGG_final_table_3(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-4") {
write.csv(KEGG_final_table_4(), file, row.names = FALSE)
}
})


```

Enriched pathway visualization
========================================
Sidebar {.sidebar data-width=350}
----------------------------------------
```{r, echo=FALSE}

checkboxGroupInput(inputId = "checkbox_Pathway", label = h5(strong("Pathway visualization")), choices = list("Pathway ORA",  "Pathway GSEA", "ReactomePA"), inline = TRUE)


fluidRow(column (4, selectInput( inputId = "Colour_high", label = strong("High"), choices = c("None", "Red","Green", "Yellow", "Blue", "Grey"), selected = "Green", width = '100%')),

column (4, selectInput( inputId = "Colour_med", label = strong("Medium"), choices = c("None","Red", "Green", "Yellow", "Blue", "Grey"), selected = "Grey", width = '100%')),

column (4, selectInput( inputId = "Colour_low", label = strong("Low"), choices = c("None","Red", "Green", "Yellow", "Blue", "Grey"), selected = "Red", width = '100%')))

checkboxGroupInput(inputId = "T1", label = h5(strong("Treatments uploaded")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"),inline = TRUE)

downloadButton(outputId = "download_pathway", label = "Download",  icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")



br()
strong(p("ALERT:- To change the enriched pathway, please rerun the pathway enrichment analysis and then select one enriched pathway in all treatments to visualize."))

downloadHandler(
filename = function(){
  if(input$checkbox_Pathway == "Pathway ORA"){
  paste0(pathway_ora_plot_1()[1, 1], "ora.pathview.png")}
  else if (input$checkbox_Pathway == "Pathway GSEA"){
  paste0(pathway_gsea_plot_1()[1, 1], "gsea.pathview.multi.png")}
  else if (input$checkbox_Pathway == "ReactomePA"){
  paste0("reactome_", pathway_react_plot_1()[1,1], ".png")
 }
      
},

content <- function(file){
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "Pathway ORA")  
{file.copy(paste0(pathway_ora_plot_1()[1, 1], ".pathview.png"), file)}
if(input$T1 != "Treatment-1" && input$checkbox_Pathway == "Pathway ORA") 
{file.copy(paste0(pathway_ora_plot_1()[1, 1], ".pathview.multi.png"), file)}  
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "Pathway GSEA")  
{file.copy(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.png"), file)}
if(input$T1 != "Treatment-1" && input$checkbox_Pathway == "Pathway GSEA") 
{file.copy(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.multi.png"), file)}  
if(input$checkbox_Pathway == "ReactomePA") 
{file.copy(paste0("reactome_", pathway_react_plot_1()[1,1], ".png"), file)} 
},
contentType = "image/png"
)

```

Column {.tabset}
-------------------------------------
### ORA pathway output
```{r, echo= FALSE}

# these codes for pathway ora treatment-1
kegg_pathview_1 <-reactive({

h_plot_data_gse_1 <- as.data.frame(pathway_ora_plot_1())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
})


# these codes for pathway ora treatment-2
kegg_pathview_2 <- reactive({

h_plot_data_gse_1 <- as.data.frame(pathway_ora_plot_2())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))

heatmap_f1 <- merge(kegg_pathview_1(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)

})


# these codes for pathway ora treatment-3
kegg_pathview_3 <- reactive({
  
h_plot_data_gse_1 <- as.data.frame(pathway_ora_plot_3())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))

heatmap_f1 <- merge(kegg_pathview_2(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)  
  
})


# these codes for pathway ora treatment-4
kegg_pathview_4 <- reactive({
  
h_plot_data_gse_1 <- as.data.frame(pathway_ora_plot_4())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))

heatmap_f1 <- merge(kegg_pathview_3(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)  
  
})



#plotting pathways selected by user

pathway_plot_1 <- reactive({

if(input$checkbox_Pathway == "Pathway ORA" && input$T1 == "Treatment-1"){

pathway_plot_data_1 <- as.data.frame(kegg_pathview_1())

ORA_path_mtrx <- as.matrix(pathway_plot_data_1[, -1])

row.names(ORA_path_mtrx) <- pathway_plot_data_1[, 1]   
    
p1.out <- pathview(gene.data = ORA_path_mtrx, pathway.id = pathway_ora_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx, 0)))), bins = list(gene= 10), low = input$Colour_high, mid = input$Colour_med, high = input$Colour_low) }

  
else if(input$checkbox_Pathway == "Pathway ORA" && input$T1 == "Treatment-2"){

pathway_plot_data_1 <- as.data.frame(kegg_pathview_2())

ORA_path_mtrx <- as.matrix(pathway_plot_data_1[, -1])

row.names(ORA_path_mtrx) <- pathway_plot_data_1[, 1]  
  
  
p2.out <- pathview(gene.data = ORA_path_mtrx, pathway.id = pathway_ora_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx, 0)))), bins = list(gene= 10), low = input$Colour_high, mid = input$Colour_med, high = input$Colour_low) }



else if(input$checkbox_Pathway == "Pathway ORA" && input$T1 == "Treatment-3"){

pathway_plot_data_1 <- as.data.frame(kegg_pathview_3())

ORA_path_mtrx <- as.matrix(pathway_plot_data_1[, -1])

row.names(ORA_path_mtrx) <- pathway_plot_data_1[, 1]  
  
  
p3.out <- pathview(gene.data = ORA_path_mtrx, pathway.id = pathway_ora_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx, 0)))), bins = list(gene= 10), low = input$Colour_high, mid = input$Colour_med, high = input$Colour_low)

}

else if(input$checkbox_Pathway == "Pathway ORA" && input$T1 == "Treatment-4"){

pathway_plot_data_1 <- as.data.frame(kegg_pathview_4())

ORA_path_mtrx <- as.matrix(pathway_plot_data_1[, -1])

row.names(ORA_path_mtrx) <- pathway_plot_data_1[, 1]  
  
p4.out <- pathview(gene.data = ORA_path_mtrx, pathway.id = pathway_ora_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx, 0)))), bins = list(gene= 10), low = input$Colour_high, mid = input$Colour_med, high = input$Colour_low)
}


})



output$pathway_ora_plot <- renderImage({
  
validate(need(input$checkbox_Pathway != "", "Please select the type of enriched pathway visualization."),
         need(input$T1 != "", "Please select the treatment you want to visualize!")
         )  
  
observeEvent(input$checkbox_Pathway, {
  showNotification("Enriched pathway visulaization upto selected treatments.", type = "message", duration = 10)
})  


outfile <- if(input$T1 == "Treatment-1") {normalizePath(paste0(pathway_ora_plot_1()[1, 1], ".pathview.png"))}
      else if(input$T1 != "Treatment-1"){normalizePath(paste0(pathway_ora_plot_1()[1, 1], ".pathview.multi.png"))}
      
pathway_plot_1()

width <- session$clientData$output_pathway_ora_plot_width
height <- session$clientData$output_pathway_ora_plot_height
          
list(src = outfile,
    width = width,
    height = height)

}, deleteFile = TRUE)


imageOutput("pathway_ora_plot")

```

### GSEA pathway output
```{r, echo= FALSE}

# these codes for pathway GSEA treatment-1
kegg_pathview_gsea_1 <-reactive({

h_plot_data_gse_1 <- as.data.frame(pathway_gsea_plot_1())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

names(h_plot_gse_1_1)[1] <- "geneID"

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
})


# these codes for pathway GSEA treatment-2
kegg_pathview_gsea_2 <- reactive({

h_plot_data_gse_1 <- as.data.frame(pathway_gsea_plot_2())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

names(h_plot_gse_1_1)[1] <- "geneID"

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))

heatmap_f1 <- merge(kegg_pathview_gsea_1(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)

})


# these codes for pathway GSEA treatment-3
kegg_pathview_gsea_3 <- reactive({
  
h_plot_data_gse_1 <- as.data.frame(pathway_gsea_plot_3())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

names(h_plot_gse_1_1)[1] <- "geneID"

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))

heatmap_f1 <- merge(kegg_pathview_gsea_2(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)  
  
})


# these codes for pathway GSEA treatment-4
kegg_pathview_gsea_4 <- reactive({
  
h_plot_data_gse_1 <- as.data.frame(pathway_gsea_plot_4())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

names(h_plot_gse_1_1)[1] <- "geneID"

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))

heatmap_f1 <- merge(kegg_pathview_gsea_3(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)  
  
})



#plotting pathways selected by user

pathway_plot_2 <- reactive({

if(input$checkbox_Pathway == "Pathway GSEA" && input$T1 == "Treatment-1"){

pathway_plot_data_12 <- as.data.frame(kegg_pathview_gsea_1())

ORA_path_mtrx_1 <- as.matrix(pathway_plot_data_12[, -1])

row.names(ORA_path_mtrx_1) <- pathway_plot_data_12[, 1]   
    
p5.out <- pathview(gene.data = ORA_path_mtrx_1, pathway.id = pathway_gsea_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx_1, 0)))), bins = list(gene= 10), low = input$Colour_high, mid = input$Colour_med, high = input$Colour_low) }


else if(input$checkbox_Pathway == "Pathway GSEA" && input$T1 == "Treatment-2"){

pathway_plot_data_12 <- as.data.frame(kegg_pathview_gsea_2())

ORA_path_mtrx_1 <- as.matrix(pathway_plot_data_12[, -1])

row.names(ORA_path_mtrx_1) <- pathway_plot_data_12[, 1]   
    
p5.out <- pathview(gene.data = ORA_path_mtrx_1, pathway.id = pathway_gsea_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx_1, 0)))), bins = list(gene= 10), low = input$Colour_high, mid = input$Colour_med, high = input$Colour_low) } 
  
else if(input$checkbox_Pathway == "Pathway GSEA" && input$T1 == "Treatment-3"){

pathway_plot_data_12 <- as.data.frame(kegg_pathview_gsea_3())

ORA_path_mtrx_1 <- as.matrix(pathway_plot_data_12[, -1])

row.names(ORA_path_mtrx_1) <- pathway_plot_data_12[, 1]   
    
p5.out <- pathview(gene.data = ORA_path_mtrx_1, pathway.id = pathway_gsea_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx_1, 0)))), bins = list(gene= 10), low = input$Colour_high, mid = input$Colour_med, high = input$Colour_low) }   
  
else if(input$checkbox_Pathway == "Pathway GSEA" && input$T1 == "Treatment-4"){

pathway_plot_data_12 <- as.data.frame(kegg_pathview_gsea_4())

ORA_path_mtrx_1 <- as.matrix(pathway_plot_data_12[, -1])

row.names(ORA_path_mtrx_1) <- pathway_plot_data_12[, 1]   
    
p5.out <- pathview(gene.data = ORA_path_mtrx_1, pathway.id = pathway_gsea_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx_1, 0)))), bins = list(gene= 10), low = input$Colour_high, mid = input$Colour_med, high = input$Colour_low) }   
  
})


output$pathway_gsea_plot <- renderImage({
  
validate(need(input$checkbox_Pathway != "", "Please select the type of enriched pathway visualization."),
         need(input$T1 != "", "Please select the treatment that you want to visualize!")
         )  

  
outfile <- if(input$T1 == "Treatment-1") {normalizePath(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.png"))}
      else if(input$T1 != "Treatment-1"){normalizePath(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.multi.png"))}

pathway_plot_2()

width <- session$clientData$output_pathway_gsea_plot_width
height <- session$clientData$output_pathway_gsea_plot_height
          
list(src = outfile,
    width = width,
    height = height)

}, deleteFile = TRUE)


imageOutput("pathway_gsea_plot")

```

### Reactome pathway output
```{r, echo= FALSE}

# these codes is for pathway reactome treatment-1
reactome_pathview_1 <-reactive({

h_plot_data_gse_1 <- as.data.frame(pathway_react_plot_1())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
})


# these codes is for pathway reactome treatment-2
reactome_pathview_2 <- reactive({

h_plot_data_gse_1 <- as.data.frame(pathway_react_plot_2())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))

heatmap_f1 <- merge(reactome_pathview_1(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)

})


# these codes is for pathway reactome treatment-3
reactome_pathview_3 <- reactive({

h_plot_data_gse_1 <- as.data.frame(pathway_react_plot_3())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))

heatmap_f1 <- merge(reactome_pathview_2(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)

})

# these codes is for pathway reactome treatment-4
reactome_pathview_4 <- reactive({

h_plot_data_gse_1 <- as.data.frame(pathway_react_plot_4())

h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]

heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))

heatmap_f1 <- merge(reactome_pathview_3(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)

})


################################
#Reactome pathway visualization#
################################


reactome_pathway_plot_1 <- reactive({
  

if(input$checkbox_Pathway == "ReactomePA" && input$T1 == "Treatment-1"){
  
react_data_1 <-  as.data.frame(reactome_pathview_1())
  
react_data_1 <- data.frame(react_data_1, row.names = 1)

data("pathways.info", "sbgn.xmls")
  
SBGNview.obj <- SBGNview(
              gene.data = react_data_1, 
              gene.id.type = "entrez",
              input.sbgn =  pathway_react_plot_1()[1,1],
              output.file = "reactome",
              col.gene.low = input$Colour_low,
              col.gene.high = input$Colour_high, 
              col.gene.mid = input$Colour_med,
              max.gene.value = max(abs(round(react_data_1, 0))),
              min.gene.value = min(round(react_data_1, 0)),
              font.size = 2,   
              output.formats =  c("png"))
print(SBGNview.obj)
}
  
if(input$checkbox_Pathway == "ReactomePA" && input$T1 == "Treatment-2"){  
data("pathways.info", "sbgn.xmls") 
   
react_data_1 <-  as.data.frame(reactome_pathview_2())
  
react_data_1 <- data.frame(react_data_1, row.names = 1)

SBGNview.obj <- SBGNview(
              gene.data = react_data_1, 
              gene.id.type = "entrez",
              input.sbgn =  pathway_react_plot_1()[1,1],
              output.file = "reactome",
              col.gene.low = input$Colour_low,
              col.gene.high = input$Colour_high, 
              col.gene.mid = input$Colour_med,
              max.gene.value = max(abs(round(react_data_1, 0))),
              min.gene.value = min(round(react_data_1, 0)),
              font.size = 2,
              output.formats =  c("png"))
print(SBGNview.obj)
}
  
if(input$checkbox_Pathway == "ReactomePA" && input$T1 == "Treatment-3"){

data("pathways.info", "sbgn.xmls") 
   
react_data_1 <-  as.data.frame(reactome_pathview_3())
  
react_data_1 <- data.frame(react_data_1, row.names = 1)

SBGNview.obj <- SBGNview(
              gene.data = react_data_1, 
              gene.id.type = "entrez",
              input.sbgn =  pathway_react_plot_1()[1,1],
              output.file = "reactome",
              col.gene.low = input$Colour_low,
              col.gene.high = input$Colour_high, 
              col.gene.mid = input$Colour_med,
              max.gene.value = max(abs(round(react_data_1, 0))),
              min.gene.value = min(round(react_data_1, 0)),
              font.size = 2,
              output.formats =  c("png"))
print(SBGNview.obj)  
  
} 
  
if(input$checkbox_Pathway == "ReactomePA" && input$T1 == "Treatment-4"){

data("pathways.info", "sbgn.xmls") 
   
react_data_1 <-  as.data.frame(reactome_pathview_4())
  
react_data_1 <- data.frame(react_data_1, row.names = 1)

SBGNview.obj <- SBGNview(
              gene.data = react_data_1, 
              gene.id.type = "entrez",
              input.sbgn =  pathway_react_plot_1()[1,1],
              output.file = "reactome",
              col.gene.low = input$Colour_low,
              col.gene.high = input$Colour_high, 
              col.gene.mid = input$Colour_med,
              max.gene.value = max(abs(round(react_data_1, 0))),
              min.gene.value = min(round(react_data_1, 0)),
              font.size = 2,
              output.formats =  c("png"))
print(SBGNview.obj)  
  
} 
  
})


output$pathway_reactome_plot <- renderImage({
  
validate(need(input$checkbox_Pathway != "", "Please select the type of enriched pathway visualization."),
         need(input$T1 != "", "Please select the treatment that you want to visualize!")
         )   

outfile <- normalizePath(paste0("reactome_", pathway_react_plot_1()[1,1], ".png"))

reactome_pathway_plot_1() 

width <- session$clientData$output_pathway_reactome_plot_width
height <- session$clientData$output_pathway_reactome_plot_height 

list(src = outfile,
width = width,
height = height)

}, deleteFile = FALSE)

imageOutput("pathway_reactome_plot")




######################
#Download tab pathway#
######################

output$download_pathway <- downloadHandler(
filename = function(){
  if(input$checkbox_Pathway == "Pathway ORA"){
  paste0(pathway_ora_plot_1()[1, 1], "ora.pathview.png")}
  else if (input$checkbox_Pathway == "Pathway GSEA"){
  paste0(pathway_gsea_plot_1()[1, 1], "gsea.pathview.multi.png")}
  else if (input$checkbox_Pathway == "ReactomePA"){
  paste0("reactome_", pathway_react_plot_1()[1,1], ".png")
 }
      
},

content <- function(file){
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "Pathway ORA")  
{file.copy(paste0(pathway_ora_plot_1()[1, 1], ".pathview.png"), file)}
if(input$T1 != "Treatment-1" && input$checkbox_Pathway == "Pathway ORA") 
{file.copy(paste0(pathway_ora_plot_1()[1, 1], ".pathview.multi.png"), file)}  
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "Pathway GSEA")  
{file.copy(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.png"), file)}
if(input$T1 != "Treatment-1" && input$checkbox_Pathway == "Pathway GSEA") 
{file.copy(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.multi.png"), file)}  
if(input$checkbox_Pathway == "ReactomePA") 
{file.copy(paste0("reactome_", pathway_react_plot_1()[1,1], ".png"), file)} 
},
contentType = "image/png"
)

```

Literature info
========================================
Sidebar {.sidebar data-width=350}
----------------------------------------
```{r, echo= FALSE}

textInput(inputId = "text_literature", label = h5(strong("Literature search")), value = "", width = "100%")

numericInput(inputId = "literature_limit", label = h5(strong("Literature retrival limit")), value = "100", min = 10, max = 5000, step = 100, width = '100%')


actionButton(inputId = "literature_submit", "Submit")

```

Column {.tabset}
------------------------------------------
### Literature info
```{r, echo= FALSE}

literature_search <- eventReactive(input$literature_submit, {europepmc::epmc_search(query = input$text_literature, limit = input$literature_limit, sort = "date")})



output$literature_result_1 <- DT::renderDataTable({

validate(need(input$text_literature != "", "Please provide input for lietrature search, example- Gene name, species, disease type, etc."),   

need(input$literature_limit != "", "Please provide input for limiting the retrieval of scientific lietrature; example 10-5000."),

need(input$literature_submit, "Please click on submit button to perform retrieval!")) 
  
  
withProgress(message = "Fetching information", detail = "According to the provided retrieval limit it will take time! ", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
  

literature_search()})},options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))

DT::dataTableOutput("literature_result_1")



#selection of one row for fetching abstract
selected_rows_literature <- reactive({
literature_rows <- input$literature_result_1_rows_selected
literature_search()[sort(literature_rows), ]})
```

### Abstract info
```{r, echo= FALSE}

selected_rows_abstract <- reactive({
  
if(is.null(input$literature_result_1_rows_selected))
    return(NULL)
  
literature_data <- as.data.frame(selected_rows_literature())

literature_data_1 <- literature_data[1, 3]

literature_detailes <- europepmc::epmc_details(literature_data_1, data_src = "med")

final_literature_1 <- literature_detailes[["basic"]]

final_literature_2 <- final_literature_1[, c(5,6,10,7,9,4)]
})

output$literature_selected <- DT::renderDataTable({
  
validate(need(input$literature_result_1_rows_selected != "", "Please provide input by selecting only one row at a time from lietrature search result table."))  


withProgress(message = "Fetching abstract;", detail = "Abstract availability depends on the data source!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
selected_rows_abstract()})},options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25))

DT::dataTableOutput("literature_selected")

```

Help
========================================
```{r, echo= FALSE}

h4(strong("The OMnalysis app permit user to visualize, analyze quantitative comparative transcriptomics data."))
p(strong("Investigate the features of application provided above, using a preloaded example of RNA-seq normalized data sets.
Upload your relative normalized data up to four treatment at a time."))


h3("INSTRUCTIONS")
p("•	The app is hosted on shiny.io website:", strong("https://omnalysis.shinyapps.io/OMnalysis/"), a( "click here", href="https://omnalysis.shinyapps.io/OMnalysis/"))
p("•	Codes are freely available at Github:", strong("https://github.com/Punit201016/OMnalysis"), a("click here", href="https://github.com/Punit201016/OMnalysis"))
p("•	You can run this app on your desktop after installing R base and R studio.")
p("•	Once the environment is ready, install packages required for OMnalysis.")
p("•	Install R shiny supporting packages")

h4(code('Install.packages(c("flexdashboard", "dplyr", "shiny", "shinydashboard", "DT", "tidyverse", "shinythemes", "tidyr", "gplots", "tibble", "gridExtra", "RColorBrewer", "slickR", "devtools", "ggbiplot", "factoextra", "ggplot2", "data.table", "VennDiagram", "fields", "wordcloud", "SBGNview", "europepmc"))'))

p("Install Bioconductor packages using:", code('Install.packages("BiocManager")'))
h4("then",code('install.packages(c("AnnotationDbi", "Biobase", "BiocFileCache", "BiocGenerics", "BiocParallel", "BiocVersion", "biomaRt", "Biostrings", "clusterProfiler", "DO.db", "DOSE", "EnhancedVolcano", "enrichplot", "fgsea", "GO.db", "GOSemSim", "graph", "graphite", "IRanges", "KEGGgraph", "KEGGREST", "org.Bt.eg.db", "org.Gg.eg.db", "org.Hs.eg.db", "org.Ss.eg.db", "pathview", "qvalue", "reactome.db", "ReactomePA", "Rgraphviz", "S4Vectors", "XVector", "zlibbioc"))'))

hr()

h3("DATA FORMAT")
strong(p("
1. Upload data must be in comma-separated-value (.CSV) file."),
p("2.	Headers must be true in the uploaded file."),
p("3.	The first column must be biomarkers (In transcriptomics – Ensembl accession number)."),
p("4.	Column names must be ENSEMBLE, logFC, log CPM, PValue for all four uploaded treatments of transcriptomics study."),

img(src = "./www/upload_table.png", height = 150, width = 730),

p("5.The data must contain expression value with their statistical significance value, as shown in the data screenshot above."))


h3("UPLOAD DATA")
img(src = "./www/om_1.png", height = 500, width = 300)
strong(p("1.	The app features can be explored using the", span(strong("Differentially expressed example data tab.", style = "color:white; background-color: black")), "Use the preloaded RNA-seq data of human brain microvascular endothelial cell line induced with four neuroinvasive pathogens (Two virus and two bacteria), capable to cause central nervous system infection. The data is published and can be acessed using", a( "click here", href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6904618/")),
p("2.	The CSV format expression matrix upto four experimental conditions with expression value (log fold change), a measure of significance (p-value), count of reads (log counts per million) can be uploaded using the", span(strong("Upload Expression data Browse tab.", style = "color:white; background-color: black")), "After uploading you may select from the currently provided species Human, Chicken, Pig and Cow with the help of", span(strong("dropdown select a species tab", style = "color:white; background-color: black")), "to perform further analysis."),
p("3.	After selection from the species, a user needs to convert the less informative accession number ENSEMBLGENE to more informative biomarkers IDs using the", span(strong("ID conversion tab.", style = "color:white; background-color: black"))),
p("4.	After mandatory ID conversion of list of genes in expression data,  user needs to click on the", span(strong(" SUBMIT button", style = "color:white; background-color: black")), "to perform the ID conversion. The converted ID data in CSV format can be downloaded using the ", span(strong("Download button.", style = "color:white; background-color: black")))
)

h3("PCA") 
img(src = "./www/om_2.png", height = 400, width = 600)
strong(p("1.	Principal component analysis (PCA) is an unsupervised dimension reduction method that allows us to understand the relationships among the attributes of expression data. PCA analysis calculates the principal components using the Euclidean distance and linear transformation of the expression data. It calculates the most significant variable in the provided data to calculates first principal component (PC1), second principal component(PC2) and so on."),
p("2.	Two types of PCA plots are provided, first  is variable PCA plot that provides information about the direction and relationship among the variables (treatments) and second is Biplot PCA that allows you to visualize the features of variable PCA plot and observation (genes) of a specific variable in one plot."),
p("3.	Most of the variables are explained in PC1 and PC2, however, only for ", span(strong(" Biplot PCA, drop-down tab", style = "color:white; background-color: black")), "is available to explore and compare the other available PCs."),
p("4.	The output of the reactive plot can be downloadble in four supporting image formats jpeg, png, pdf and tiff."),
p("5.	The dimension and the resolution of output PCA plot can be adjusted with the help of ", span(strong(" numerical input tabs.", style = "color:white; background-color: black")), " The default value are 20, 20 and 300 for width, height and resolution respectively."),
p("6. After providing all the necessary information you can download the PCA plot using ", span(strong(" Download button.", style = "color:white; background-color: black")))
)


h3("Plots")
img(src = "./www/om_3.png", height = 500, width = 700)
strong(p("1.	Scatter plot uses log fold change versus log counts per million to visualize your expression data in the form of up and down-regulated genes. Each dot in the scatter plot represents up-regulated genes (green colour),  non-significant genes (black colour) and downregulated genes (red colour)."),
p("2.	The", span(strong("slider input", style = "color:white; background-color: black")), " option is available for the user to provide the numeric input P-value cutoff for both plots and FC-cutoff for volcano plot required to generate plots. The default numeric P-value cutoff is 0.02 and FC-cutoff is 1.2."),
p("3.	Using", span(strong("plot title ", style = "color:white; background-color: black")), "option user can write a title to the generated plot (ex- Treatment-1)."), 
p("4.	Volcano plot uses log fold change versus -log10 (P-value) so that the most significant and highly upregulated and downregulated genes can be visualized. In the volcano plot each red rhombus shape represents the gene with their gene name on it."),
p("5.	After selecting the treatment user have to click on the", span(strong("checkbox of plots", style = "color:white; background-color: black")), "required to generate plots and Table to visualize the each treatment data with converted ids."),
p("6.	The output of the plots can be downloadable in four supporting image formats jpeg, png, pdf and tiff using the drop-down format option."),
p("7.	The dimension and the resolution of output plots can be adjusted with the help of", span(strong("numerical input tabs.", style = "color:white; background-color: black")), "The default value is 20, 20 and 300 for width, height and resolution respectively."),
p("8.	After providing all the necessary information user can download the plots with the help of ", span(strong("Download button.", style = "color:white; background-color: black")) 
))

h3("Statistical filtering")
img(src = "./www/om_4.png", height = 600, width = 700)
strong(p("1.	With the help of ", span(strong("checkbox button treatments 1, 2, 3 and 4", style = "color:white; background-color: black"))," user can visualize the data and plot of the selected treatment."),
p("2.", span(strong("Three numerical input boxes", style = "color:white; background-color: black"))," are provided to filter out the genes that are unable to cross the threshold values. Three statistical parameters are log counts per million (expression value), log fold change (magnitude of change) and P-value (value of significance) provided to obtain significantly differentially expressed genes."),
p("3.	Use the", span(strong("Venn diagram checkbox", style = "color:white; background-color: black"))," to visualize the common significantly differentially expressed genes in the uploaded treatments. Also, you can use a Venn diagram to obtain common or different up and down-regulated genes sharing in two groups of treatments."),
p("4.	The dimension and the resolution of output Venn diagram and histogram can be adjusted with the help of ", span(strong("numerical input tabs.", style = "color:white; background-color: black"))," The default value is 20, 20 and 300 for width, height and resolution respectively."),
p("5.	Two separate ", span(strong("download tabs", style = "color:white; background-color: black"))," first and second are provided to download Venn diagram and histogram respectively."),
p("6.	Using ", span(strong("histogram", style = "color:white; background-color: black")),"you can visualize the number of differentially expressed genes that falls on the log fold change range. Additionally, by using ", span(strong("all treatment checkbox ", style = "color:white; background-color: black")),"you can visualize the total number of up and down-regulated genes avialble in each treatment in a single histogram."),
p("7.	Using", span(strong("Title", style = "color:white; background-color: black"))," option user can write the title to the generated diagram or histogram (ex- Treatment-1)."),
p("8.	The Venn diagram and histogram can be downloadable in four supporting image formats jpeg, png, pdf and tiff using the drop-down format option."),
p("9.	The generated diagram can be downloaded using the ", span(strong("Download button.", style = "color:white; background-color: black")))
)


h3("Gene ontology (GO) enrichment analysis")
img(src = "./www/om_5.png", height = 400, width = 750)
strong(p("1.	Use the ", span(strong("ontology classes checkbox", style = "color:white; background-color: black"))," to perform the categorical analysis of your expression data, either in the biological process (multiple molecular activities integrates to perform a process) or molecular function (activities at the molecular level by gene product) or cellular component (site of function concerning cellular structure)."),
p("2. ", span(strong("	P-value cutoff", style = "color:white; background-color: black"))," and the ", span(strong("q-value cutoff", style = "color:white; background-color: black"))," are provided to obtain enriched test and significantly enriched test respectively. The default p-value and q-value cutoff is 0 and can be adjusted to 0.01 and 0.05."),
p("3.	The methods provided to perform ", span(strong("gene ontology enrichment analysis", style = "color:white; background-color: black"))," are over-represented analysis (ORA), (based on hypergeometric test and mapping of genes to the annotated biological vocabulary) and gene set enrichment analysis (GSEA), (based on the Kolmogorov Smirnov test and consider gene set with their log fold change value)."),
p("4.	The gene ontology analysis main panel is populated with ", span(strong("subtabs Ontology result-1, Ontology result-2, Ontology result-3, and  Ontology result-4 ", style = "color:white; background-color: black"))," each subtab shows the output result of the analysis."),
p("5.	After providing the necessary inputs click on the ", span(strong("Go button ", style = "color:white; background-color: black")),"to launch the enrichment analysis. Please keep in mind that in each treatment ontology enrichment analysis the same input values will be used."),
p("6.	In the drop-down ", span(strong("pAadjust method tab,", style = "color:white; background-color: black")),"  7 adjustment methods Holm, Hochberg, Hommel,  Bonferroni,  Benjamini and Hochberg (BH),  Benjamini and Yekutieli (BY), FDR and none are provided to control false postive result. Above mentioned first four methods control the family-wise error rate (probability of making one or more false discoveries) and remaining methods control the expected proportion of discoveries that are rejected falsely (FDR). We suggest FDR correction methods for a more reliable result."),
p("7.	From the ontology result table, you need to provide one go term by selecting only one row and same term in all the treatments. This information will be used for the visualization of heatmaps in the next GO heatmaps panel."),
p("8.	These gene ontology result can be downloaded in CSV format by clicking on ", span(strong("treatment checkbox and Download button.", style = "color:white; background-color: black")))
) 


h3("GO heatmaps")
img(src = "./www/om_6.png", height = 600, width = 700)
strong(p("1.	GO heatmaps are the expression values of genes that mapped to the biological term while performing gene ontology enrichment analysis."),
p("2.	It is mandatory to select at least two similar enriched GO terms from the previous tabular output of GO enrichment analysis of two treatments. "),
p("3.	Two options are available ", span(strong("checkbox ORA and GSEA heatmap visualization", style = "color:white; background-color: black"))," (to generate the heatmap, however, the output depends on the previous GO enrichment analysis method."),
p("4.	With the help of ", span(strong("checkbox button treatments 1, 2, 3 and 4", style = "color:white; background-color: black")),"user can visualize the heatmap and a word cloud of the selected treatment. It is mandatory to select at least two treatments to generate the heatmap."), 
p("5.	To adjust the ", span(strong("column, row text and col key size three numerical tabs", style = "color:white; background-color: black")),"are available and the default value for column text, row text and colour key size is 1.2, 1.2 and 0.04 respectively."), 
p("6.	User can provide text input to assign a ", span(strong("title for heatmap.", style = "color:white; background-color: black"))),
p("7.	The heatmap and word cloud can be downloadable in four supporting image formats jpeg, png, pdf and tiff using the ", span(strong("drop-down format option.", style = "color:white; background-color: black"))),
p("8.	The dimension and the resolution of output heatmap and word cloud can be adjusted with the help of ", span(strong("numerical input in tabs plot width, plot height and plot resolution.", style = "color:white; background-color: black"))," The default value is 20, 20 and 300 for width, height and resolution respectively."), 
p("9.	After providing the necessary information user can download the generated heatmap using the ", span(strong("Download button.", style = "color:white; background-color: black"))),
p("10.	Word cloud in GO heatmaps shows the enriched GO texts that have the highest to lowest number of genes mapped to it."),
p("11.	With the help of ", span(strong("word cloud checkbox", style = "color:white; background-color: black")),"user can generate the word cloud of selected treatment and type of enrichment method used."),
p("12.	Using the ", span(strong("max words numeric input tab", style = "color:white; background-color: black")),"  option user can increase or decrease the number of enriched go terms visualization in the word cloud. The default value of the maximum words in the word cloud in 100."),
p("13.	The generated word cloud diagram can be downloaded using the ", span(strong("Download button.", style = "color:white; background-color: black"))),
p("14.	After examining the annotation using GO enrichment analysis, you may proceed to pathway enrichment analysis."))

h3("Pathway enrichment analysis")
img(src = "./www/om_7.png", height = 500, width = 750)
strong(p("1.	This section provides the databases and methods available to perform pathway analysis."),
p("2.	The options provided are over-represented analysis (ORA), (based on hypergeometric test), gene set enrichment analysis (GSEA), (based on the Kolmogorov Smirnov test), network topology analysis (NTA), ( uses genes, their expression value, and network arrangements (edges and nodes), Reactome pathway analysis uses Reactome database to perform pathway analysis."),
p("3.	The default p-value cutoff is 0 and can be adjusted to get significant result, however, 0.05 p-value cutoff can be used as it is applied in the first filter to discard the non-significant gene set and then by removing false positives result by applying pAdjust mehtod. This stringency may result in a fewer number of gene set ranked."),
p("4.	In enrichment analysis, gene sets are compared multiple times to the universal datasets and in each run it increases the chances of a false positive result, to overcome this problem multiple adjustment methods are provided."), 
p("5.	In the ", span(strong("drop-down pAadjust method tab,", style = "color:white; background-color: black")),"  7 adjustment methods Holm, Hochberg, Hommel,  Bonferroni,  Benjamini and Hochberg (BH),  Benjamini and Yekutieli (BY), FDR and to bypass these methods none is available. Above mentioned first four methods control the family-wise error rate (probability of making one or more false discoveries) and remaining methods control the expected proportion of discoveries that are rejected falsely (FDR). We suggest FDR correction methods for a more reliable result."),
p("6.	To support NTA four database are provided, biocarta (protein sets participating in the pathway), panther (a curated and comprehensive database to classify protein and their genes through evolutionary relationship), NCI-Nature Pathway Interaction Database (Signaling pathways composed of human biomolecular interactions and cellular processes) and pharmgkb (a comprehensive resource that provides information about how human genetic variation affects the response to medications)."),
p("7.	After providing the inputs, click on the ", span(strong("Go tab", style = "color:white; background-color: black"))," to launch the pathway enrichment analysis. Please keep in mind that in each treatment, the same set of information will be used to execute pathway enrichment analysis. "), 
p("8.	To perform pathway enrichment analysis in all treatments you don’t need to click and provide input each time, instead, you can click on the ", span(strong("subtabs Pathway result-2, Pathway result-3, and Pathway result-4", style = "color:white; background-color: black"))," to execute analysis."),
p("9.	Pathway enrichment analysis section has ", span(strong("subtabs, Pathway result-1, Pathway result-2, Pathway result-3, and Pathway result-4.", style = "color:white; background-color: black"))," Once the analysis completed a table of enrichment pathways will be displayed in the pathway subtabs."),
p("10.	From the pathway analysis result table, you need to select one same enriched pathway by selecting only one row in all treatments. This information will be used for the visualization of the expressed gene in the next section enriched pathway visualization."),
p("11.	These Pathway enrichment result can also be downloaded in CSV format by", span(strong("clicking on treatment checkbox and Download button.", style = "color:white; background-color: black"))))

h3("Enriched pathway Visualization")
img(src = "./www/om_8.png", height = 250, width = 750)
strong(p("1.	After selecting the single and same pathway in all the treatments from the pathway enrichment result table, you can visualize the pathway using ", span(strong("pathway visualization tabs.", style = "color:white; background-color: black")), "and according to the pathway enrichment method performed earlier."),
p("2.	Three options are  available Pathway ORA, Pathway GSEA, ReactomePA. You can select any one of them and view the output on the right side ", span(strong("subtabs panel of ORA pathway output or GSEA pathway output or Reactome pathway output.", style = "color:white; background-color: black"))),
p("3.	If the previous pathway enrichment analysis was ORA then only ORA pathway will be visualized in the ORA pathway output subtab, if not, it will show an error."),
p("4.	Once you are on the ORA, GSEA or  pathway output, you can visualize genes set of four treatments with their log fold change value. The colour code can be changed using three tabs,", span(strong(" highly expressed (High), medium expressed (Medium) and lowly expressed genes (Low).", style = "color:white; background-color: black"))),
p("5.	The default colour code for high is green, for medium grey and low in red. You can select more colour combination from the none, red, green, yellow, blue, and grey to visualize the expression values on enriched pathway."),
p("6.	Once you have selected the colour code, you need to select among the treatments provided under the header ", span(strong("Treatments uploaded", style = "color:white; background-color: black")),"that you desire to visualize on the enriched pathway."),
p("7. The output from the reactome pathway analysis can be intrepret using the below notation image."),
img(src = "./www/om_10.png", height = 500, width = 750),
p("8.	Keep in mind that the visualization of pathways depends on the pathway enrichment analysis method and selection of the same pathway in all treatments."),
p("9.	On the left bottom, ", span(strong("Download tab", style = "color:white; background-color: black"))," is provided to download the pathway image of ORA, GSEA and ReactomePA output in PNG image format."))



h3("Literature info")
img(src = "./www/om_9.png", height = 200, width = 980)
strong(p("1.	This section provides the option to retrieve the information from the Europe PMC by providing biomarkers id, species, disease, cell or tissue type in the text input tab provided below ", span(strong("Literature search header.", style = "color:white; background-color: black"))),
p("2.	The Literature retrieval limit has an input option to provided number that will decide the fetching of the literatures in number."),
p("3.	Once the literature search and retrieval limit is provided, you can proceed with the ", span(strong("submit button", style = "color:white; background-color: black"))," to perform the retrieval of scientific literature."),
p("4.	After completion of the retrieval process, the result in tabular form will appear in the right side subtab literature info panel."), 
p("5.	On literature info table you have to select one scientific literature row at a time to view the abstract and other information on the next subtab", span(strong(" Abstract info.", style = "color:white; background-color: black"))),
p("6.	If the keyword provided in the Literature search is not correct then the result may produce an error or blank table of literature info."))


```
