---
title: "OMNALYSIS"
output:
  flexdashboard::flex_dashboard:
    theme: simplex
    orientation: rows
    vertical_layout: fill
    Runtime: shiny
runtime: shiny
resource_files:
- biocartaEx1SPIA.RData
- nciEx1SPIA.RData
- pantherEx1SPIA.RData
- pharmgkbEx1SPIA.RData
- reactome_ids.RData
- www/heatmap.png
- www/Histogram.png
- www/Histogram_1.png
- www/hsa04668.pathview.multi.png
- www/PCA plot.png
- www/reactome_R-HSA-909733.png
- www/Scatter plot treatment-1.png
- www/Venn Diagram.png
- www/wordcloud.png
---

```{r setup, include=FALSE}
library(flexdashboard)
library(shiny)
library(shinydashboard)
library(dplyr)
library(shinythemes)
library(DT)
library(slickR)
library(rio)
library(plyr)
```

# Welcome

## Column {data-height="430"}

### Introduction

```{r, echo=FALSE}
div(h3(strong("Welcome to OMnalysis"), style = "display: inline; font-family: 'Lobster', cursive;font-weight: 500; line-height: 1.1; margin-top: 20px; margin-bottom: 20px; color: #4d3a7d;"), h6("An integrated web application to explore quantitative differential omics data!"))
h5(p(strong("OMnalysis is powered with well established and highly used R Bioconductor packages to mine faithful biological information from the differential omics data.")))
h5(strong("Upload the differential omics data upto four treatments and with few clicks see the magic!"))
h4(strong("Features"), style = "font-family: 'Lobster', cursive;color: #4d3a7d; margin-top: 0px;")
h6(strong("1. User friendly with multiple additional options."))
h6(strong("2. Currently support four species (Human, Cow, Pig and Chicken)."))
h6(strong("3. Most upto date accession ID conversion."))
h6(strong("4. Pulication ready high resoltution images."))
```

### Support

```{r,echo=FALSE}
img(src = "./www/om_panel/MANNA_logo.png", height = 150, width = 730)
br()
h5(p(strong("This project has received funding from the European Union’s Horizon 2020 research and innovation programme H2020-MSCA- ITN-2017- EJD: Marie Skłodowska-Curie Innovative Training Networks (European Joint Doctorate) – Grant agreement nº: 765423 – MANNA.")))
```

## Column {data-height="570"}

### Plots

```{r, echo=FALSE}
output$slickr <- renderSlickR({ 
    imgs <- list.files(path = "./www/",all.files = TRUE, pattern=".png", full.names = TRUE)
    slickR(imgs, width = 1700, height = 330) + settings(autoplay = TRUE)
  })
slickROutput("slickr")
  
```

### Omnalysis workflow

```{r, echo=FALSE}
img(src = "./www/om_panel/OMnalysis_1.png", height = 365, width = 730)
```

# Upload data

## Sidebar {.sidebar data-width="350"}

```{r, echo=FALSE}
br()
shinyjs::useShinyjs(rmd = TRUE)
div(style = "width: 150px;", actionButton(inputId = "uploaded_ex", "Differentially expressed example data"))

div(.progress = {"height: 0px;"}, fileInput(inputId = "inFile", label = h5(strong("Upload expression data")),
multiple = TRUE, accept = c(
                    "text/csv",
                    "text/comma-separated-values",
                    "text/plain",
                    ".csv")))

div(style = "width: 150px;", actionButton(inputId = "uploaded_ex1", "Proteomics abundance example data"))

div(.progress = {"height: 0px;"}, fileInput(inputId = "inFile1", label = h5(strong("Upload abundance data")),
multiple = TRUE, accept = c(
                    "text/csv",
                    "text/comma-separated-values",
                    "text/plain",
                    ".csv")))

actionLink("reset_1", strong("Reset"))
selectInput("select1", label = h5 (strong("Select a species")), choices = c("Human" = 1, "Chicken"= 2, "Pig"= 3, "Cow"= 4), selected = NULL)
div(style = "display: inline-block; width: 150px;", selectInput("select2", label = h5(strong("ID conversion")), choices = c("Ensembl gene ID", "UniProtKB/Swiss-Prot ID")))
div(style = "display: inline-block; width: 150px;", selectInput("select3", label = "", choices = c("Ensembl gene ID" = 1, "Gene name"= 2, "HGNC symbol"= 3, "Gene description" = 4, "UniProtKB/Swiss-Prot ID" = 5), selected = NULL))
actionButton("ID_submit", "Submit")
br()
downloadButton(outputId = "downloadData", label = "Download",  icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")
downloadHandler(
filename = function(){
paste("Converted ID", ".csv", sep = "")
},
content = function(file){
write.csv(data_list_2(), file, row.names = FALSE)
}
)

downloadHandler(
filename = function(){
paste("Converted ID", ".csv", sep = "")
},
content = function(file){
write.csv(data_list_3(), file, row.names = FALSE)
}
)
br()
strong(p("ALERT:- Gene ID conversion is mandatory for further analysis."))
rmarkdown::render_delayed({
library(EnhancedVolcano)
library(tidyr)
library(biomaRt)
library(tidyverse)
library(gplots)
library(tibble)
library(gridExtra)
library(RColorBrewer)
library(devtools)
library(ggbiplot)
library(factoextra)
library(ggplot2)
library(clusterProfiler)
library(org.Hs.eg.db)
library(data.table)
library(VennDiagram)
library(fields)
library(wordcloud)
library(org.Gg.eg.db)
library(org.Ss.eg.db)
library(org.Bt.eg.db)
library(ReactomePA)
library(reactome.db)
library(europepmc)
library(pathview)
library(SPIA)
library(shinyjs)
library(futile.logger)
library(SBGNview)
library(STRINGdb)
library(magick)
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")
set.seed(1234)
})
```

## TAB {.tabset}

### Transcriptomics output

```{r, echo=FALSE}
rv <- reactiveValues(data = NULL)
observe({
  req(input$inFile)
  rv$data <- read.csv(input$inFile$datapath)
})
observe({
  req(input$uploaded_ex)
  rv$data <- read.csv("Test_t.csv", header = TRUE)
  })
observeEvent(input$reset_1, {
  rv$data <- NULL
  reset("inFile")
})
observeEvent(input$reset_1, {
  rv$data <- NULL
  reset("uploaded_ex")
})

datasetInput <- reactive({
rv$data
})

#Transcriptomics data
data_list_1 <- eventReactive(input$ID_submit, {
#selection from the user
if (input$select1 == 1) {species_dataset <- "hsapiens_gene_ensembl"} 
else if (input$select1 == 2) {species_dataset <- "ggallus_gene_ensembl"}
else if (input$select1 == 3) {species_dataset <- "sscrofa_gene_ensembl"}
else if (input$select1 == 4) {species_dataset<- "btaurus_gene_ensembl"}
ensembl <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset =  species_dataset, host = "uswest.ensembl.org")})

data_list_2 <- eventReactive(input$ID_submit, {
#Selection of the attributes from the user(geneID) TAB-2
if (input$select3 == 1) {species_attributes <- "ensembl_gene_id"} 
else if (input$select3 == 2) {species_attributes <- "external_gene_name"}
else if (input$select3 == 3) {species_attributes <- "hgnc_symbol"}
else if (input$select3 == 4) {species_attributes <- "description"}
else if (input$select3 == 5) {species_attributes <- "uniprotswissprot"}

#Mapping of the input data to the  
Mapped_gene  <- getBM(attributes = c("ensembl_gene_id", species_attributes), filters = "ensembl_gene_id", values = datasetInput(), mart = data_list_1())
Converted_gene_id <- merge(datasetInput(), Mapped_gene, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
})

output$Table_output_1 <- DT::renderDataTable({ 

if(input$ID_submit > 0){
withProgress(message = "ID conversion is in Progress",  detail = "Fetching data from ensembl!", value = 0,
     {
       for(i in 1:10)
       {incProgress(1/15)
         Sys.sleep(0.2)}
       
       data_list_2()
     })
}
else return(datasetInput())
}, options = list(scroller = TRUE, scrollY = 510, scrollX = TRUE, pageLength = 25))
DT::dataTableOutput("Table_output_1") 

output$downloadData <- downloadHandler(
filename = function() {
paste0("Converted ID", ".csv", sep = "")
},
content = function(file)
{write.csv(data_list_2(), file, row.names = FALSE)
}
)
```

### Proteomics output

```{r, echo=FALSE}
#for proteomics data

rv1 <- reactiveValues(data1 = NULL)
observe({
  req(input$inFile1)
  rv1$data1 <- import_list(input$inFile1$datapath, setclass = "tbl", rbind = TRUE)
})
observe({
  req(input$uploaded_ex1)
  rv1$data1 <- import_list("Proteomics_data.xlsx", setclass = "tbl", rbind = TRUE)
  })
observeEvent(input$reset_1, {
  rv1$data1 <- NULL
  reset("inFile1")
})
observeEvent(input$reset_1, {
  rv1$data1 <- NULL
  reset("uploaded_ex1")
})

datasetInput1 <- reactive({
if (is.null(rv1$data1)){return(NULL)}
prot_data_1 <- rv1$data1
protein_list_2 <- filter(.data = prot_data_1, prot_data_1[3] > 0) #filtering logfc value
protein_list_3 <- filter(.data = prot_data_1, prot_data_1[3] < 0)
protein_list_4 <- as.data.frame(log2(protein_list_2[[3]])) # log transformation
protein_list_5 <- as.data.frame(-log2(abs(protein_list_3[[3]])))#log2base of negative value
colnames(protein_list_4)[1] <- "logFC"
colnames(protein_list_5)[1] <- "logFC"
protein_list_5_1 <- rbind(protein_list_2, protein_list_3)
protein_list_5_2 <- rbind(protein_list_4, protein_list_5)
prot_final_1 <- cbind(protein_list_5_1, protein_list_5_2)
prot_final_1 <- prot_final_1[, c(1,2,5,4)]
colnames(prot_final_1)[4] <- "Treatments"
prot_final_1
newddf <- prot_final_1 %>% group_by(`UniProt ID`, Treatments) %>% summarise(logFC = mean(logFC))
newddf$`FDR-adjusted P-value` <-  prot_final_1$`FDR-adjusted P-value`[match(newddf$`UniProt ID`, prot_final_1$`UniProt ID`)]
newddf <- newddf[, c(1, 4, 3, 2)]
as.data.frame(newddf)
})

data_list_3 <- eventReactive(input$ID_submit, {
#Selection of the attributes from the user(geneID) TAB-2
if (input$select3 == 1) {species_attributes <- "ensembl_gene_id"} 
else if (input$select3 == 2) {species_attributes <- "external_gene_name"}
else if (input$select3 == 3) {species_attributes <- "hgnc_symbol"}
else if (input$select3 == 4) {species_attributes <- "description"}
else if (input$select3 == 5) {species_attributes <- "uniprotswissprot"}

#Mapping of the input data to the  
Mapped_gene1  <- getBM(attributes = c("uniprotswissprot", species_attributes), filters = "uniprotswissprot", values = datasetInput1(), mart = data_list_1())
Converted_gene_id1 <- merge(datasetInput1(), Mapped_gene1, by.x = "UniProt ID", by.y = "uniprotswissprot")
})

output$Table_output_2 <- DT::renderDataTable({ 

  
if(input$ID_submit > 0){
withProgress(message = "ID conversion is in Progress",  detail = "Fetching data from ensembl!", value = 0,
     {
       for(i in 1:10)
       {incProgress(1/15)
         Sys.sleep(0.2)}
       
       data_list_3()
     })
}
else return(datasetInput1())
}, options = list(scroller = TRUE, scrollY = 510, scrollX = TRUE, pageLength = 25))
DT::dataTableOutput("Table_output_2") 

output$downloadData1 <- downloadHandler(
filename = function() {
paste0("Converted ID", ".csv", sep = "")
},
content = function(file)
{write.csv(data_list_3(), file, row.names = FALSE)
}
)

```

# PCA

## Sidebar {.sidebar data-width="350"}

```{r, echo=FALSE}
checkboxGroupInput(inputId = "PCA_M", label = h5(strong("Principal component analysis")), choices = c("Variables PCA", "Biplot PCA"), inline = TRUE)
div(style = "display: inline-block; width: 150px;", selectInput("PCA_C", label =  h5(strong("Compare PCA only for biplot")), choices = c("PC1" = 1, "PC2"= 2, "PC3"= 3, "PC4" = 4), selected = 1))
div(style = "display: inline-block; width: 150px;", selectInput("PCA_C_2", label = "", choices = c("PC1" = 1, "PC2"= 2, "PC3"= 3, "PC4" = 4), selected = 2))
selectInput(inputId = "select_PCA", label = h5(strong("Format")), choices = c("jpeg", "png", "pdf", "tiff"))
fluidRow(column (4, numericInput(inputId = "Download_PCA_input1",  label = h6("width"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_PCA_input2",  label = h6("height"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput(inputId = "Download_PCA_input3",  label = h6("resolution"), value = 300, min = 150, max = 500, step = 50, width = '100%')))
downloadButton(inputId = "PCA_plot", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")

downloadHandler(
filename = function(){
paste("PCA plot", input$select_PCA, sep = ".")
},
content = function(file){
if(input$PCA_M > 0){ggsave(file, plot(Plot_PCA_1()), device = input$select_PCA, width = input$Download_PCA_input1, height = input$Download_PCA_input2, units = "cm", dpi = input$Download_PCA_input3)}
else {ggsave(file, plot(Plot_PCA_2()), device = input$select_PCA, width = input$Download_PCA_input1, height = input$Download_PCA_input2, units = "cm", dpi = input$Download_PCA_input3)}
}
)


```

## TAB {.tabset}

### Plot visualization transcriptomics

```{r, echo=FALSE}

Plot_PCA_1 <- reactive({
PCA_T1 <- data_list_2()[, -c(1,3,4,6,7,9,10,12,13,15,16)]
PCA_T1.pca <- prcomp(PCA_T1[, -ncol(PCA_T1)], scale. = TRUE, center = TRUE)

if (input$PCA_M == "Variables PCA"){
PCA_plot_VA <- fviz_pca_var(PCA_T1.pca, col.var = "contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
}
else if(input$PCA_M == "Biplot PCA"){
  
PCA_T1$col <- suppressWarnings(factor(colnames(PCA_T1)[apply(PCA_T1, 1L, which.max)]))
PCA_plot <- ggbiplot(PCA_T1.pca, choices = c(input$PCA_C:input$PCA_C_2), scale = 1, groups = PCA_T1$col, ellipse = TRUE,varname.adjust = 1, varname.size = 6, labels = data_list_2()[, ncol(data_list_2())] )+ theme_bw()+ theme(text = element_text(size=20)) + scale_color_discrete(name = '') + theme(legend.direction = 'horizontal', legend.position = 'top') + scale_x_continuous(breaks = seq(-20, 20, by = 2)) + scale_y_continuous(n.breaks = 10)}
})

output$PCA_plot_1 <- renderPlot({
validate(need(input$PCA_M != "", "Please select type of PCA visualization to generate plot."))    
if (input$PCA_M == "Biplot PCA"){withProgress(message = "Constructing PCA biplot ", detail = "between the user selected Principal componenets!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Plot_PCA_1())}
  
else if(input$PCA_M == "Variables PCA"){withProgress(message = "Constructing plot between the variables ", detail = "PCA plot between the uploaded treatments!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Plot_PCA_1())}
})
plotOutput("PCA_plot_1")

output$PCA_plot <- downloadHandler(
filename = function(){
paste("PCA plot", input$select_PCA, sep = ".")
},
content = function(file){
if(input$PCA_M > 0)
{ggsave(file, plot(Plot_PCA_1()), device = input$select_PCA, width = input$Download_PCA_input1, height = input$Download_PCA_input2, units = "cm", dpi = input$Download_PCA_input3)}
else {ggsave(file, plot(Plot_PCA_2()), device = input$select_PCA, width = input$Download_PCA_input1, height = input$Download_PCA_input2, units = "cm", dpi = input$Download_PCA_input3)}
}
)


```

### Plot visualization Proteomics

```{r, echo=FALSE}
Plot_PCA_prot1 <- reactive({
  
prot_final_2 <- as.data.frame(datasetInput1()) 

#separating list according to the treatments
prot_t1 <- subset(prot_final_2, Treatments == 1, select = c(names(prot_final_2))) 
prot_t2 <- subset(prot_final_2, Treatments == 2, select = c(names(prot_final_2)))
prot_t3 <- subset(prot_final_2, Treatments == 3, select = c(names(prot_final_2)))
prot_t4 <- subset(prot_final_2, Treatments == 4, select = c(names(prot_final_2)))

#merging the file 
final_prot_PCA <- merge(x = prot_t1, y = prot_t2, by= "UniProt ID", all= TRUE)
final_prot_PCA_1 <- merge(x = prot_t3, y = prot_t4, by= "UniProt ID", all= TRUE)
final_prot_PCA_2 <- merge(x = final_prot_PCA, y = final_prot_PCA_1, by= "UniProt ID", all= TRUE)

#renaming the headers
names(final_prot_PCA_2)[c (3,6,9,12)] <- c("logFC","logFC1","logFC2","logFC3")

#converting NA to 0 in the file to compute PCA
final_prot_PCA_2[, -c(1)][is.na(final_prot_PCA_2[, -c(1)])] <- 0
final_prot_PCA_3 <- final_prot_PCA_2
})

#for PCA analysis
Plot_PCA_2 <- reactive({
PCA_T1 <- Plot_PCA_prot1()
PCA_T1 <- PCA_T1[, c(1,3,6,9,12)]


PCA_T1.pca <- prcomp(PCA_T1[, -1], scale. = TRUE, center = TRUE)

if (input$PCA_M == "Variables PCA"){
PCA_plot_VA <- fviz_pca_var(PCA_T1.pca, col.var = "contrib", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
}
else if(input$PCA_M == "Biplot PCA"){
PCA_T1$col <- suppressWarnings(factor(colnames(PCA_T1)[apply(PCA_T1, 1L, which.max)]))
PCA_plot <- ggbiplot(PCA_T1.pca, choices = c(input$PCA_C:input$PCA_C_2), scale = 1, groups = PCA_T1$col, ellipse = TRUE, varname.adjust = 1, varname.size = 6, labels = PCA_T1$`UniProt ID`)+ theme_bw()+ theme(text = element_text(size=12)) + scale_color_discrete(name = '') + theme(legend.direction = 'horizontal', legend.position = 'top') + scale_x_continuous(breaks = seq(-20, 20, by = 2)) + scale_y_continuous(n.breaks = 10)}
})


output$PCA_plot_3 <- renderPlot({
validate(need(input$PCA_M != "", "Please select type of PCA visualization to generate plot."))    
if (input$PCA_M == "Biplot PCA"){withProgress(message = "Constructing PCA biplot ", detail = "between the user selected Principal componenets!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Plot_PCA_2())}
  
else if(input$PCA_M == "Variables PCA"){withProgress(message = "Constructing plot between the variables ", detail = "PCA plot between the uploaded treatments!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Plot_PCA_2())}
})
plotOutput("PCA_plot_3")


# for download PCA images
output$PCA_plot <- downloadHandler(
filename = function(){
paste("PCA plot", input$select_PCA, sep = ".")
},
content = function(file){
if(input$PCA_M > 0)
{ggsave(file, plot(Plot_PCA_1()), device = input$select_PCA, width = input$Download_PCA_input1, height = input$Download_PCA_input2, units = "cm", dpi = input$Download_PCA_input3)}
else {ggsave(file, plot(Plot_PCA_2()), device = input$select_PCA, width = input$Download_PCA_input1, height = input$Download_PCA_input2, units = "cm", dpi = input$Download_PCA_input3)}
}
)


```

# Plots

## Sidebar {.sidebar data-width="350"}

```{r, echo=FALSE}
tags$style(
HTML(
  ".checkbox-inline { 
              margin-left: 0px;
              margin-right: 20px;
              padding-right: 0px;
    }
   .checkbox-inline+.checkbox-inline {
              margin-left: 0px;
              margin-right: 20px;
   }
    
  "
)
) 
tags$style(
HTML(".control-label{
  align = left;
}"
)
)
         
  
 
tags$div(class = "checkbox-inline; .control-label;",checkboxGroupInput(inputId = "T_plot", label = h5(strong("Uploaded treatments")), choices = list("Treatment-1" = 1, "Treatment-2" = 2, "Treatment-3" = 3, "Treatment-4" = 4), inline = TRUE))
fluidRow(column (5, numericInput( inputId = "slider_1", label =  h5(strong("Pvalue cutoff ")), min = 0, max = 0.5, value = 0.001, step = 0.01, width = "100%")),
column(5, numericInput( inputId ="slider_2", label= h5(strong("FC-cutoff")), min = 0, max = 15, value = 1.2 , step = 0.5, width = "100%")))
textInput(inputId = "text1", label = h5(strong("Plot Title")), value = "please fill main title")
checkboxGroupInput(inputId = "checkbox", label = h5(strong("Plots")), choices = c("Scatter plot transcriptomics", "Volcano plot transcriptomics", "Volcano plot proteomics", "Table"), inline = TRUE)
selectInput(inputId = "select4", label = h5(strong("Format")), choices = c("jpeg", "png", "pdf", "tiff"))
fluidRow(column (4, numericInput( inputId = "Download_plot_input1",  label = h6("width"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_plot_input2",  label = h6("height"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput(inputId = "Download_plot_input3",  label = h6("resolution"), value = 300, min = 150, max = 500, step = 50, width = '100%')))
downloadButton(inputId = "Plot_Volcano_1", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")

#Plots download
downloadHandler(
filename = function(){
paste(input$text1, input$select4, sep = ".")
},
content = function(file){
if(input$checkbox == "Scatter plot transcriptomics"){ggsave(file,  
plot(Plot_scatter_1()), device = input$select4, width = input$Download_plot_input1, height = input$Download_plot_input2, dpi = input$Download_plot_input3, units = "cm")}
else if(input$checkbox == "Volcano plot transcriptomics"){ggsave(file, plot(Volcano_plot_1()) , device = input$select4, width = input$Download_plot_input1, height = input$Download_plot_input2, dpi = input$Download_plot_input3, units = "cm")}
else if(input$checkbox == "Volcano plot proteomics"){ggsave(file, plot(Volcano_plot_2()) , device = input$select4, width = input$Download_plot_input1, height = input$Download_plot_input2, dpi = input$Download_plot_input3, units = "cm")}  
  
})
```

## Column {.tabset}

### Scatter Plot

```{r, echo= FALSE}
converted_data <- eventReactive(input$T_plot == TRUE, {
Treatment_1 <- as.data.frame(data_list_2())
if (input$T_plot == 1){T_plot_1 <- Treatment_1[, c(1:4, ncol(Treatment_1))]}
else if (input$T_plot == 2){T_plot_1 <- Treatment_1[, c(1, 5:7, ncol(Treatment_1))]}
else if (input$T_plot == 3){T_plot_1 <- Treatment_1[, c(1, 8:10, ncol(Treatment_1))]}
else if (input$T_plot == 4){T_plot_1 <- Treatment_1[, c(1, 11:13, ncol(Treatment_1))]}
})

Plot_scatter_1 <- reactive({
if (input$checkbox == "Scatter plot transcriptomics"){
converted_1 <- as.data.frame(converted_data()) 
converted_1$Differential_Expression <- "Non-significant"
converted_1$Differential_Expression[converted_data()[, 2] > input$slider_2] <- "Up"
converted_1$Differential_Expression[converted_data()[, 2] < -(input$slider_2)] <- "Down"
 
g1 <- ggplot(data = converted_data(), aes(x = converted_1[, 3], y = converted_1[, 2], col= converted_1$Differential_Expression)) + geom_point(size = 3)+ scale_x_continuous(breaks = seq(-20, 20, by = 2)) + scale_y_continuous(n.breaks = 10) + theme_bw() + xlab("logCPM") + ylab("logFC") + scale_color_manual(name = "Differential Expression", values = c("red", "black","green")) + theme(text = element_text(size=20), plot.title = element_text(hjust = 0.5)) + ggtitle(input$text1)
}
})
output$plot_scatter <- renderPlot({
validate(
need(input$T_plot != "", "Please select the treatment for generating plot!"), 
need(input$checkbox != "", "Please select the type of plot.")
)
if(input$checkbox == "Scatter plot transcriptomics"){withProgress(message = "Constructing scatter plot.", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Plot_scatter_1())}
})
plotOutput("plot_scatter")
```

### Volcano Plot

```{r, echo= FALSE}

#### data for proteomics scatter plot
converted_data_1 <- eventReactive(input$T_plot == TRUE, {
prot_final_2 <- datasetInput1() 
if (input$T_plot == 1){T_plot_1 <- subset(prot_final_2, Treatments == 1, select = c(names(prot_final_2)))}
else if (input$T_plot == 2){T_plot_1 <- subset(prot_final_2, Treatments == 2, select = c(names(prot_final_2)))}
else if (input$T_plot == 3){T_plot_1 <- subset(prot_final_2, Treatments == 3, select = c(names(prot_final_2)))}
else if (input$T_plot == 4){T_plot_1 <- subset(prot_final_2, Treatments == 4, select = c(names(prot_final_2)))}
})

#Scatter plot for transcriptomics and proteomics 
Volcano_plot_1 <- reactive({
if(input$checkbox == "Volcano plot transcriptomics"){ 
g2 <- EnhancedVolcano(toptable = converted_data(), lab = converted_data()[, 5],  x = names(converted_data()[2]), y = names(converted_data()[4]), pCutoff = input$slider_1, titleLabSize = 20, title = input$text1, FCcutoff = input$slider_2, labhjust = 0.5, labSize = 4) + scale_x_continuous(breaks = seq(-20, 20, by = 2)) + scale_y_continuous(n.breaks = 10)
}
})

Volcano_plot_2 <- reactive({  
if(input$checkbox == "Volcano plot proteomics"){
g3 <- EnhancedVolcano(toptable = converted_data_1(), lab = converted_data_1()[, 1],  x = names(converted_data_1()[3]), y = names(converted_data_1()[2]), pCutoff = input$slider_1, titleLabSize = 20, title = input$text1, FCcutoff = input$slider_2, labhjust = 0.5, labSize = 4) + scale_x_continuous(breaks = seq(-20, 20, by = 2)) + scale_y_continuous(n.breaks = 10)
}
  })

#Plot visualization
output$plot_volcano <- renderPlot({
validate(
need(input$T_plot != "", "Please select the treatment for generating plot!"), 
need(input$checkbox != "", "Please select the type of plot.")
)
if (input$checkbox == "Volcano plot transcriptomics"){
withProgress(message = "Constructing Volcano Plot!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Volcano_plot_1())
}

else if (input$checkbox == "Volcano plot proteomics"){
withProgress(message = "Constructing Proteomics Volcano Plot!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Volcano_plot_2())
} 
  })

plotOutput("plot_volcano")
```

### Treatment table

```{r, echo=FALSE}
gene_Table_1 <- eventReactive(input$T_plot == TRUE,{
Treatment_1 <- as.data.frame(data_list_2())
if (input$T_plot == 1){T_plot_1 <- Treatment_1[, c(1:4, ncol(Treatment_1))]}
else if (input$T_plot == 2){T_plot_1 <- Treatment_1[, c(1, 5:7, ncol(Treatment_1))]}
else if (input$T_plot == 3){T_plot_1 <- Treatment_1[, c(1, 8:10, ncol(Treatment_1))]}
else if (input$T_plot == 4){T_plot_1 <- Treatment_1[, c(1, 11:13, ncol(Treatment_1))]}
})

#Table presentation
output$converted_data <- DT::renderDataTable({
validate(need(input$T_plot != "", "Please select the treatment to show table with converted IDs!"),   
need(input$checkbox != "", "Please select the table option to show.")) 
if(input$checkbox == "Table"){gene_Table_1()}}, options = list(scroller = TRUE, scrollY = 510, scrollX = TRUE, pageLength = 25))
DT::dataTableOutput("converted_data")



#Download function of plots
output$Plot_Volcano_1 <- downloadHandler(
filename = function(){
paste(input$text1, input$select4, sep = ".")
},
content = function(file){
if(input$checkbox == "Scatter plot transcriptomics"){ggsave(file,  
plot(Plot_scatter_1()), device = input$select4, width = input$Download_plot_input1, height = input$Download_plot_input2, dpi = input$Download_plot_input3, units = "cm")}
else if(input$checkbox == "Volcano plot transcriptomics"){ggsave(file, plot(Volcano_plot_1()) , device = input$select4, width = input$Download_plot_input1, height = input$Download_plot_input2, dpi = input$Download_plot_input3, units = "cm")}
else if(input$checkbox == "Volcano plot Proteomics"){ggsave(file, plot(Volcano_plot_2()) , device = input$select4, width = input$Download_plot_input1, height = input$Download_plot_input2, dpi = input$Download_plot_input3, units = "cm")}  
  
})
```

# Statistical filtering

## Sidebar {.sidebar data-width="350"}

```{r, echo=FALSE}
checkboxGroupInput(inputId = "T1_filter", label = h5(strong("Treatments uploaded")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"), inline = TRUE)

selectInput(inputId = "select_omics", label = h5(strong("Omics Type")), choices = c("Transcriptomics", "Proteomics"))

h5(strong("Statistical filtering"))
fluidRow(column (4, numericInput( inputId = "Numeric_input1",  label = h6("LogFC"), value = 0, min = 0, max = 25, step = 0.5, width = '100%')),
column (4, numericInput( inputId = "Numeric_input2",  label = h6("LogCPM"), value = 0, min = -15, max = 25, step = 0.5, width = '100%')),
column (4, numericInput( inputId = "Numeric_input3",  label = h6("Pvalue"), value = 0, min = -20, max = 20, step = 0.01, width = '100%')))
checkboxGroupInput(inputId = "checkbox_2", label = h5(strong("Venn Diagram")), choices = list("Split into Up and Down-regulated", "VennDiagram"), inline = FALSE)
fluidRow(column (4, numericInput( inputId = "Download_input1",  label = h6("width"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_input2",  label = h6("height"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_input3",  label = h6("resolution"), value = 300, min = 100, max = 600, step = 50, width = '100%')))
downloadButton(inputId = "Downloadplot_1", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")

downloadHandler(
filename =function(){paste("Venn Diagram", tolower(input$select_format), sep = ".")
},
content = function(file){
if (input$select_format == "jpeg")
{jpeg(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "png")
{png(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "pdf")
{pdf(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "tiff")
{tiff(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
}
)
checkboxGroupInput(inputId = "checkbox_3", label = h5(strong ("Histogram")), choices = list("Treatment", "All Treatments"), inline = TRUE)
textInput(inputId = "text2", label = h5(strong("Title")), value = "")
selectInput(inputId = "select_format", label = h5(strong("Format")), choices = c("jpeg", "png", "pdf", "tiff"))


#For download plots
downloadHandler(
filename =function(){paste("Histogram", tolower(input$select_format), sep = ".")
},
content = function(file){
if(input$checkbox_3 == "Treatment"){ggsave(file, plot(Histogram_plot_1()), device = tolower(input$select_format), width = input$Download_input1, height = input$Download_input2, dpi = input$Download_input3, units = "cm")}
else if(input$checkbox_3 == "All Treatments"){ggsave(file, plot(Histogram_plot_all()), device = tolower(input$select_format), width = input$Download_input1, height = input$Download_input2, dpi = input$Download_input3, units = "cm")}
}
)
```

## Column {.tabset}

### Filtered data

```{r, echo= FALSE}

Filtertable1 <- reactive({
df_1 <- as.data.frame(data_list_2())
df_2 <- dplyr::select(.data = df_1, ENSEMBLGENE, logFC, logCPM, Pvalue)
filter(.data = df_2, 
logFC > input$Numeric_input1 | logFC < -(input$Numeric_input1), 
logCPM >= input$Numeric_input2, 
Pvalue < input$Numeric_input3) %>% unique()
})

Filtertable2 <- reactive({
df_1 <- as.data.frame(data_list_2())
df_2 <- dplyr::select(.data = df_1, ENSEMBLGENE, logFC.1, logCPM.1, Pvalue.1)
filter(.data = df_2, 
logFC.1 > input$Numeric_input1 | logFC.1 < -(input$Numeric_input1), 
logCPM.1 >= input$Numeric_input2, 
Pvalue.1 < input$Numeric_input3) %>% unique()
})

Filtertable3 <- reactive({
df_1 <- as.data.frame(data_list_2())
df_2 <- dplyr::select(.data = df_1, ENSEMBLGENE, logFC.2, logCPM.2, Pvalue.2)
filter(.data = df_2, 
logFC.2 > input$Numeric_input1 | logFC.2 < -(input$Numeric_input1), 
logCPM.2 >= input$Numeric_input2, 
Pvalue.2 < input$Numeric_input3) %>% unique()
})

Filtertable4 <- reactive({
df_1 <- as.data.frame(data_list_2())
df_2 <- dplyr::select(.data = df_1, ENSEMBLGENE, logFC.3, logCPM.3, Pvalue.3)
filter(.data = df_2, 
logFC.3 > input$Numeric_input1 | logFC.3 < -(input$Numeric_input1), 
logCPM.3 >= input$Numeric_input2, 
Pvalue.3 < input$Numeric_input3) %>% unique()
})


#for proteomics data
Filtertable1_1 <- reactive({
prot_final_2 <- as.data.frame(datasetInput1()) 

#separating list according to the treatments
prot_t1 <- subset(prot_final_2, Treatments == 1, select = c(names(prot_final_2))) 

df_2 <- prot_t1 %>% filter(logFC > input$Numeric_input1 | logFC < -(input$Numeric_input1), `FDR-adjusted P-value` < input$Numeric_input3)
})

Filtertable2_2 <- reactive({
prot_final_2 <- as.data.frame(datasetInput1()) 

#separating list according to the treatments
prot_t1 <- subset(prot_final_2, Treatments == 2, select = c(names(prot_final_2)))

df_2 <- prot_t1 %>% filter(logFC > input$Numeric_input1 | logFC < -(input$Numeric_input1), `FDR-adjusted P-value` < input$Numeric_input3)
})

Filtertable3_3 <- reactive({
prot_final_2 <- as.data.frame(datasetInput1()) 

#separating list according to the treatments
prot_t1 <- subset(prot_final_2, Treatments == 3, select = c(names(prot_final_2)))
df_2 <- prot_t1 %>% filter(logFC > input$Numeric_input1 | logFC < -(input$Numeric_input1), `FDR-adjusted P-value` < input$Numeric_input3)
})

Filtertable4_4 <- reactive({
prot_final_2 <- as.data.frame(datasetInput1()) 

#separating list according to the treatments
prot_t1 <- subset(prot_final_2, Treatments == 4, select = c(names(prot_final_2)))
df_2 <- prot_t1 %>% filter(logFC > input$Numeric_input1 | logFC < -(input$Numeric_input1), `FDR-adjusted P-value` < input$Numeric_input3)
})


filter_data_1 <- reactive({
if (input$T1_filter == "Treatment-1"){Filtertable1()}
else if (input$T1_filter == "Treatment-2"){Filtertable2()}
else if (input$T1_filter == "Treatment-3"){Filtertable3()}
else if (input$T1_filter == "Treatment-4"){Filtertable4()}
})

filter_data_2 <- reactive({
if (input$T1_filter == "Treatment-1"){Filtertable1_1()}
else if (input$T1_filter == "Treatment-2"){Filtertable2_2()}
else if (input$T1_filter == "Treatment-3"){Filtertable3_3()}
else if (input$T1_filter == "Treatment-4"){Filtertable4_4()}
})


filter_data <- reactive({
if (input$select_omics == "Transcriptomics"){filter_data_1()}
else if(input$select_omics == "Proteomics"){(filter_data_2())}
})


output$filtered_data <- DT::renderDataTable({
validate(need(input$T1_filter != "" , "Please select the treatment to view filtered table!"))   
df_filter <- as.data.frame(filter_data())
df_filter
}, options = list(scroller = TRUE, scrollY = 400, scrollX = TRUE, pageLength = 20))
DT::dataTableOutput("filtered_data")
```

### Venn Diagram

```{r, echo= FALSE}

#Venn diagram code for transcriptomics data
df_3 <- reactive({as.data.frame(Filtertable1(), stringsAsFactors = TRUE)})
A_1 <- reactive({df_3()[, 1] %>% unlist()})
A <- reactive({dplyr::select(filter(.data = df_3(), logFC > 0), 1) %>% unlist()})
B <- reactive({dplyr::select(filter(.data = df_3(), logFC < 0), 1) %>% unlist()})
df_4 <- reactive({as.data.frame(Filtertable2(), stringsAsFactors = TRUE)})
A_2 <- reactive({df_4()[, 1] %>% unlist()})
C <- reactive({dplyr::select(filter(.data = df_4(), logFC.1 > 0), 1) %>% unlist()})
D <- reactive({dplyr::select(filter(.data = df_4(), logFC.1 < 0), 1) %>% unlist()})
df_5 <- reactive({as.data.frame(Filtertable3(), stringsAsFactors = TRUE)})
A_3 <- reactive({df_5()[, 1] %>% unlist()})
E <- reactive({dplyr::select(filter(.data = df_5(), logFC.2 > 0), 1) %>% unlist()})
G <- reactive({dplyr::select(filter(.data = df_5(), logFC.2 < 0), 1) %>% unlist()})
df_6 <- reactive({as.data.frame(Filtertable4(), stringsAsFactors = TRUE)})
A_4 <- reactive({df_6()[, 1] %>% unlist()})
H <- reactive({dplyr::select(filter(.data = df_6(), logFC.3 > 0), 1) %>% unlist()})
I <- reactive({dplyr::select(filter(.data = df_6(), logFC.3 < 0), 1) %>% unlist()})


VENN_plot_1 <- eventReactive(input$checkbox_2 == "Split into Up and Down-regulated", {
observeEvent(input$checkbox_2 == "Split into Up and Down-regulated", {
showNotification("Please select atleast two treatments to generate venn diagram.",  type = "message", duration = 10)
})  
  
if(all(c("Treatment-1", "Treatment-2") %in% input$T1_filter) == TRUE) 
{Venn1.plot <- venn.diagram(x= list(A= A(), B= B(), C= C(), D= D()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 1", "Down regulated 1", "Up regulated 2", "Down regulated 2"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}
else if(all(c("Treatment-2", "Treatment-3") %in% input$T1_filter) == TRUE)
{Venn1.plot <- venn.diagram(x= list(A= C(), B= D(), C= E(), D= G()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 2", "Down regulated 2", "Up regulated 3", "Down regulated 3"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}  
else if(all(c("Treatment-2", "Treatment-4") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= C(), B= D(), C= H(), D= I()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 2", "Down regulated 2", "Up regulated 4", "Down regulated 4"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}    
else if(all(c("Treatment-3", "Treatment-4") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= E(), B= G(), C= H(), D= I()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 3", "Down regulated 3", "Up regulated 4", "Down regulated 4"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}    
else if(all(c("Treatment-1", "Treatment-3") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= A(), B= B(), C= E(), D= G()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 1", "Down regulated 1", "Up regulated 2", "Down regulated 2"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}
else if(all(c("Treatment-1", "Treatment-4") %in% input$T1_filter) == TRUE)
{Venn1.plot <- venn.diagram(x= list(A= A(), B= B(), C= H(), D= I()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 1", "Down regulated 1", "Up regulated 2", "Down regulated 2"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")}
})


#VennDiagram codes
VENN_plot_2 <- reactive({
if(all(c("Treatment-1", "Treatment-2") %in% input$T1_filter) == TRUE){
Venn2.plot <-venn.diagram(x= list(A= A_1(), B= A_2()), fill = c("red", "blue"), cex = 2, cat.cex = 1.5, sub.cex = 5, main.cex = 2,  category.names = c("Treatment-1", "Treatment-2"), height = 4000, width = 6000, scale = TRUE, main = input$text2, resolution = 500, units = "cm", filename = NULL)
}
else if(all(c("Treatment-1", "Treatment-3") %in% input$T1_filter) == TRUE){
Venn2.plot <- venn.diagram(x= list(A= A_1(), B= A_2(), C= A_3()), fill = c("red", "blue", "green"), cex = 2, cat.cex = 1.5, sub.cex = 5, main.cex = 2,  category.names = c("Treatment-1", "Treatment-2", "Treatment-3"), height = 4000, width = 6000, scale = TRUE, main = input$text2, resolution = 500, units = "cm", filename = NULL)
}
else if (all(c("Treatment-1", "Treatment-4") %in% input$T1_filter) == TRUE){
Venn2.plot <- venn.diagram(x= list(A= A_1(), B= A_2(), C= A_3(), D= A_4()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, main.cex = 2, category.names = c("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"), height = 4000, width = 6000, scale = TRUE, main = input$text2, resolution = 500, units = "cm", filename = NULL)
}
})


#codes for proteomics venn diagram
df_3_1 <- reactive({as.data.frame(Filtertable1_1(), stringsAsFactors = TRUE)})
AA_1 <- reactive({df_3_1()[, 1] %>% unlist()})
A_1_1 <- reactive({dplyr::select(filter(.data = df_3_1(), logFC > 0), 1) %>% unlist()})
B_1 <- reactive({dplyr::select(filter(.data = df_3_1(), logFC < 0), 1) %>% unlist()})
df_4_1 <- reactive({as.data.frame(Filtertable2_2(), stringsAsFactors = TRUE)})
A_2_1 <- reactive({df_4_1()[, 1] %>% unlist()})
C_1 <- reactive({dplyr::select(filter(.data = df_4_1(), logFC > 0), 1) %>% unlist()})
D_1 <- reactive({dplyr::select(filter(.data = df_4_1(), logFC < 0), 1) %>% unlist()})
df_5_1 <- reactive({as.data.frame(Filtertable3_3(), stringsAsFactors = TRUE)})
A_3_1 <- reactive({df_5_1()[, 1] %>% unlist()})
E_1 <- reactive({dplyr::select(filter(.data = df_5_1(), logFC > 0), 1) %>% unlist()})
G_1 <- reactive({dplyr::select(filter(.data = df_5_1(), logFC < 0), 1) %>% unlist()})
df_6_1 <- reactive({as.data.frame(Filtertable4_4(), stringsAsFactors = TRUE)})
A_4_1 <- reactive({df_6_1()[, 1] %>% unlist()})
H_1 <- reactive({dplyr::select(filter(.data = df_6_1(), logFC > 0), 1) %>% unlist()})
I_1 <- reactive({dplyr::select(filter(.data = df_6_1(), logFC < 0), 1) %>% unlist()})


VENN_plot_3 <- eventReactive(input$checkbox_2 == "Split into Up and Down-regulated", {
  
if(all(c("Treatment-1", "Treatment-2") %in% input$T1_filter) == TRUE) 
{Venn1.plot <- venn.diagram(x= list(A= A_1_1(), B= B_1(), C= C_1(), D= D_1()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 1", "Down regulated 1", "Up regulated 2", "Down regulated 2"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}
else if(all(c("Treatment-2", "Treatment-3") %in% input$T1_filter) == TRUE)
{Venn1.plot <- venn.diagram(x= list(A= C_1(), B= D_1(), C= E_1(), D= G_1()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 2", "Down regulated 2", "Up regulated 3", "Down regulated 3"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}  
else if(all(c("Treatment-2", "Treatment-4") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= C_1(), B= D_1(), C= H_1(), D= I_1()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 2", "Down regulated 2", "Up regulated 4", "Down regulated 4"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}    
else if(all(c("Treatment-3", "Treatment-4") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= E_1(), B= G_1(), C= H_1(), D= I_1()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 3", "Down regulated 3", "Up regulated 4", "Down regulated 4"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}    
else if(all(c("Treatment-1", "Treatment-3") %in% input$T1_filter) == TRUE )
{Venn1.plot <- venn.diagram(x= list(A= A_1_1(), B= B_1(), C= E_1(), D= G_1()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 1", "Down regulated 1", "Up regulated 2", "Down regulated 2"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")
}
else if(all(c("Treatment-1", "Treatment-4") %in% input$T1_filter) == TRUE)
{Venn1.plot <- venn.diagram(x= list(A= A_1_1(), B= B_1(), C= H_1(), D= I_1()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, height = 4000, width = 6000,  main.cex = 2, category.names = c("Up regulated 1", "Down regulated 1", "Up regulated 2", "Down regulated 2"), scale = TRUE, filename = NULL, main = input$text2, resolution = 500, units = "cm")}
})


#VennDiagram codes proteomics
VENN_plot_4 <- reactive({
if(all(c("Treatment-1", "Treatment-2") %in% input$T1_filter) == TRUE){
Venn2.plot <-venn.diagram(x= list(A= AA_1(), B= A_2_1()), fill = c("red", "blue"), cex = 2, cat.cex = 1.5, sub.cex = 5, main.cex = 2,  category.names = c("Treatment-1", "Treatment-2"), height = 4000, width = 6000, scale = TRUE, main = input$text2, resolution = 500, units = "cm", filename = NULL)
}
else if(all(c("Treatment-1", "Treatment-3") %in% input$T1_filter) == TRUE){
Venn2.plot <- venn.diagram(x= list(A= A_1_1(), B= A_2_1(), C= A_3_1()), fill = c("red", "blue", "green"), cex = 2, cat.cex = 1.5, sub.cex = 5, main.cex = 2,  category.names = c("Treatment-1", "Treatment-2", "Treatment-3"), height = 4000, width = 6000, scale = TRUE, main = input$text2, resolution = 500, units = "cm", filename = NULL)
}
else if (all(c("Treatment-1", "Treatment-4") %in% input$T1_filter) == TRUE){
Venn2.plot <- venn.diagram(x= list(A= A_1_1(), B= A_2_1(), C= A_3_1(), D= A_4_1()), fill = c("red", "blue", "green", "yellow"), cex = 2, cat.cex = 1.5, sub.cex = 5, main.cex = 2, category.names = c("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"), height = 4000, width = 6000, scale = TRUE, main = input$text2, resolution = 500, units = "cm", filename = NULL)}
})


#Visualization
Venn_draw_1 <- reactive({
if(c("Split into Up and Down-regulated" %in% input$checkbox_2) && ("Transcriptomics" %in% input$select_omics)){VENN_plot_1()}
else if(c("Split into Up and Down-regulated" %in% input$checkbox_2) && ("Proteomics" %in% input$select_omics)){VENN_plot_3()}
else if(c("VennDiagram" %in% input$checkbox_2) && ("Transcriptomics" %in% input$select_omics))
{VENN_plot_2()}
else if(c("VennDiagram" %in% input$checkbox_2) && ("Proteomics" %in% input$select_omics))
{VENN_plot_4()}
})

output$Venn_Plot1 <- renderPlot({
  
validate(need(input$T1_filter != "" , "Please select the treatments in pairs to construct the split venn diagram!"),
need(input$checkbox_2 != "", "Please select the choice of venn diagram!")
) 
withProgress(message = "Constructing venn diagram", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
grid::grid.draw(Venn_draw_1())
})
plotOutput("Venn_Plot1")
```

### Histogram

```{r, echo= FALSE}

#codes for transcriptomics
all_histo_1 <- reactive({
if(input$select_omics == "Transcriptomics"){
A_1 <- as.data.frame(A())
df_histo_1 <- data.frame(logFC = nrow(A_1), regulation = "Up") %>% add_column(Treatments = "Treatment-1")
B_1 <- as.data.frame(B())
df_histo_1_1 <- data.frame(logFC = nrow(B_1), regulation = "Down") %>% add_column(Treatments = "Treatment-1")
rbind.data.frame(df_histo_1, df_histo_1_1)
}
else if(input$select_omics == "Proteomics"){
A_1 <- as.data.frame(A_1_1())
df_histo_1 <- data.frame(logFC = nrow(A_1), regulation = "Up") %>% add_column(Treatments = "Treatment-1")
B_1 <- as.data.frame(B_1())
df_histo_1_1 <- data.frame(logFC = nrow(B_1), regulation = "Down") %>% add_column(Treatments = "Treatment-1")
rbind.data.frame(df_histo_1, df_histo_1_1)
}
})


all_histo_2 <- reactive({
if(input$select_omics == "Transcriptomics"){
C_1 <- as.data.frame(C())
df_histo_2 <- data.frame(logFC = nrow(C_1), regulation = "Up") %>% add_column(Treatments = "Treatment-2")
D_1 <- as.data.frame(D())
df_histo_2_2 <- data.frame(logFC = nrow(D_1), regulation = "Down") %>% add_column(Treatments = "Treatment-2")
rbind.data.frame(as.data.frame(all_histo_1()), df_histo_2, df_histo_2_2)
}
else if(input$select_omics == "Proteomics"){
C_1 <- as.data.frame(C_1())
df_histo_2 <- data.frame(logFC = nrow(C_1), regulation = "Up") %>% add_column(Treatments = "Treatment-2")
D_1 <- as.data.frame(D_1())
df_histo_2_2 <- data.frame(logFC = nrow(D_1), regulation = "Down") %>% add_column(Treatments = "Treatment-2")
rbind.data.frame(as.data.frame(all_histo_1()), df_histo_2, df_histo_2_2)
}
})


all_histo_3 <- reactive({
if(input$select_omics == "Transcriptomics"){
E_1 <- as.data.frame(E())
df_histo_3 <- data.frame(logFC = nrow(E_1), regulation = "Up") %>% add_column(Treatments = "Treatment-3")
G_1 <- as.data.frame(G())
df_histo_3_3 <- data.frame(logFC = nrow(G_1), regulation = "Down") %>% add_column(Treatments = "Treatment-3")
rbind.data.frame(as.data.frame(all_histo_2()), df_histo_3, df_histo_3_3)
}
else if(input$select_omics == "Proteomics"){
E_1 <- as.data.frame(E_1())
df_histo_3 <- data.frame(logFC = nrow(E_1), regulation = "Up") %>% add_column(Treatments = "Treatment-3")
G_1 <- as.data.frame(G_1())
df_histo_3_3 <- data.frame(logFC = nrow(G_1), regulation = "Down") %>% add_column(Treatments = "Treatment-3")
rbind.data.frame(as.data.frame(all_histo_2()), df_histo_3, df_histo_3_3)
}  
})

all_histo_4 <- reactive({  
if(input$select_omics == "Transcriptomics"){
H_1 <- as.data.frame(H())
df_histo_4 <- data.frame(logFC = nrow(H_1), regulation = "Up") %>% add_column(Treatments = "Treatment-4")
I_1 <- as.data.frame(I())
df_histo_4_4 <- data.frame(logFC = nrow(I_1), regulation = "Down") %>% add_column(Treatments = "Treatment-4")
rbind.data.frame(as.data.frame(all_histo_3()), df_histo_4, df_histo_4_4)
}
else if(input$select_omics == "Proteomics"){
H_1 <- as.data.frame(H_1())
df_histo_4 <- data.frame(logFC = nrow(H_1), regulation = "Up") %>% add_column(Treatments = "Treatment-4")
I_1 <- as.data.frame(I_1())
df_histo_4_4 <- data.frame(logFC = nrow(I_1), regulation = "Down") %>% add_column(Treatments = "Treatment-4")
rbind.data.frame(as.data.frame(all_histo_3()), df_histo_4, df_histo_4_4)
}  
  })


Histogram_plot_1 <- reactive({
#Treatment wise histogram codes for transcriptomics  
if(c("Treatment-1" %in% input$T1_filter) && ("Transcriptomics" %in% input$select_omics))
{H_plot1 <- ggplot(df_3(), aes(x = logFC))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3()[, 2]), max(df_3()[, 2]), by = 2), 1)) + scale_y_continuous() + theme_bw()+ theme(text = element_text(size=20))}
  
else if(c("Treatment-2" %in% input$T1_filter) && ("Transcriptomics" %in% input$select_omics))
{H_plot2 <- ggplot(df_4(), aes(x = logFC.1))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3()[, 2]), max(df_3()[, 2]), by = 2), 1)) + scale_y_continuous() + theme_bw()+ xlab("logFC")+ theme(text = element_text(size=20))}
  
else if(c("Treatment-3" %in% input$T1_filter) && ("Transcriptomics" %in% input$select_omics))
{H_plot3 <- ggplot(df_5(), aes(x = logFC.2))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3()[, 2]), max(df_3()[, 2]), by = 2), 1)) + scale_y_continuous() + theme_bw()+ xlab("logFC")+ theme(text = element_text(size=20))}
  
else if(c("Treatment-4" %in% input$T1_filter) && ("Transcriptomics" %in% input$select_omics))
{H_plot4 <- ggplot(df_6(), aes(x = logFC.3))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3()[, 2]), max(df_3()[, 2]), by = 2), 1)) + scale_y_continuous() + theme_bw() + xlab("logFC")+ theme(text = element_text(size=20))} 

  
  
# Treatment wise histogram codes for proteomics  
else if(c("Treatment-1" %in% input$T1_filter) && ("Proteomics" %in% input$select_omics))
{H_plot1 <- ggplot(df_3_1(), aes(x = logFC))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3_1()[, 3]), max(df_3_1()[, 3]), by = 2), 1)) + scale_y_continuous() + theme_bw()+ theme(text = element_text(size=20))}
  
else if(c("Treatment-2" %in% input$T1_filter) && ("Proteomics" %in% input$select_omics))
{H_plot2 <- ggplot(df_4_1(), aes(x = logFC))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_3_1()[, 3]), max(df_4_1()[, 3]), by = 2), 1)) + scale_y_continuous() + theme_bw()+ xlab("logFC")+ theme(text = element_text(size=20))}
  
else if(c("Treatment-3" %in% input$T1_filter) && ("Proteomics" %in% input$select_omics))
{H_plot3 <- ggplot(df_5_1(), aes(x = logFC))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_5_1()[, 3]), max(df_5_1()[, 3]), by = 2), 1)) + scale_y_continuous() + theme_bw()+ xlab("logFC")+ theme(text = element_text(size=20))}
  
else if(c("Treatment-4" %in% input$T1_filter) && ("Proteomics" %in% input$select_omics))
{H_plot4 <- ggplot(df_6_1(), aes(x = logFC))+ geom_histogram(bins = 50, binwidth = 0.8, color= "yellow", fill="blue") + ggtitle(input$text2)+ scale_x_continuous(breaks = round(seq(min(df_6_1()[, 3]), max(df_6_1()[, 3]), by = 2), 1)) + scale_y_continuous() + theme_bw() + xlab("logFC")+ theme(text = element_text(size=20))}  
  })


Histogram_plot_all <-  reactive({
  
observeEvent(input$checkbox_3 == "All Treatments", {
  showNotification("Please select upto treatments to generate histogram", type = "message", duration = 10)
})  
if(input$T1_filter == "Treatment-1"){H_plot1 <- ggplot(all_histo_1(), aes(x= all_histo_1()[, 1], y= all_histo_1()[, 3], fill= all_histo_1()[, 2] )) + geom_bar(stat="identity", position= "dodge") + ggtitle(input$text2) + theme_bw() + xlab("Number of genes") + ylab("") + geom_text(aes(label=all_histo_1()[, 1]), color="Black", position = position_dodge(0.9), size= 6) + theme(text = element_text(size=20))+ labs(fill = "regulation")
}
else if(input$T1_filter == "Treatment-2"){H_plot2 <- ggplot(all_histo_2(), aes(x= all_histo_2()[, 1], y= all_histo_2()[, 3], fill= all_histo_2()[, 2] )) + geom_bar(stat="identity", position= "dodge") + ggtitle(input$text2) + theme_bw() + xlab("Number of genes") + ylab("") + geom_text(aes(label=all_histo_2()[, 1]), color="Black", position = position_dodge(0.9), size= 6) + theme(text = element_text(size=20))+ labs(fill = "regulation")
}
else if(input$T1_filter == "Treatment-3"){H_plot3 <- ggplot(all_histo_3(), aes(x= all_histo_3()[, 1], y= all_histo_3()[, 3], fill= all_histo_3()[, 2])) + geom_bar(stat="identity", position= "dodge") + ggtitle(input$text2) + theme_bw() + xlab("Number of genes") + ylab("") + geom_text(aes(label=all_histo_3()[, 1]), color="Black", position = position_dodge(0.9), size= 6) + theme(text = element_text(size=20))+ labs(fill = "regulation")
}
else if(input$T1_filter == "Treatment-4"){H_plot4 <- ggplot(all_histo_4(), aes(x= all_histo_4()[, 1], y= all_histo_4()[, 3], fill= all_histo_4()[, 2] )) + geom_bar(stat="identity", position= "dodge") + ggtitle(input$text2) + theme_bw() + xlab("Number of genes") + ylab("") + geom_text(aes(label=all_histo_4()[, 1]), color="Black", position = position_dodge(0.9), size= 6) + theme(text = element_text(size=20))+ labs(fill = "regulation")
}
})
output$Hist_plot1 <- renderPlot({
validate(
need(input$T1_filter != "" , "Please select the treatments to construct the histogram!"),
need(input$checkbox_3 != "", "Please select the choice of histogram required!")
)  
if(input$checkbox_3 == "Treatment"){
withProgress(message = "Constructing histogram for only one treatment.", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Histogram_plot_1())}
else if (input$checkbox_3 == "All Treatments"){
  
withProgress(message = "Constructing histogram upto selected treatments.", detail = "One treatment is selected at a time!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
})
plot(Histogram_plot_all())}
})
plotOutput("Hist_plot1")

output$Downloadplot_1 <- downloadHandler(
filename =function(){paste("Venn Diagram", tolower(input$select_format), sep = ".")
},
content = function(file){
if (input$select_format == "jpeg")
{jpeg(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "png")
{png(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "pdf")
{pdf(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
else if (input$select_format == "tiff")
{tiff(file, width = input$Download_input1, height = input$Download_input2, res = input$Download_input3, units = "cm")
grid::grid.draw(Venn_draw_1())
dev.off()}
}
)
output$Downloadplot_2 <- downloadHandler(
filename =function(){paste("Histogram", tolower(input$select_format), sep = ".")
},
content = function(file){
if(input$checkbox_3 == "Treatment"){ggsave(file, plot(Histogram_plot_1()), device = tolower(input$select_format), width = input$Download_input1, height = input$Download_input2, dpi = input$Download_input3, units = "cm")}
else if(input$checkbox_3 == "All Treatments"){ggsave(file, plot(Histogram_plot_all()), device = tolower(input$select_format), width = input$Download_input1, height = input$Download_input2, dpi = input$Download_input3, units = "cm")}
}
)
```

# GO enrichment analysis

## Sidebar {.sidebar data-width="350"}

```{r, echo= FALSE}

selectInput(inputId = "select_omics_GO", label = h5(strong("Omics Type")), choices = c("Transcriptomics", "Proteomics"))

checkboxGroupInput(inputId = "select_GO", label = h5(strong("Gene ontology classes")), choices = list("GO Biological Process" = 1, "GO Molecular Function" = 2, "GO Cellular Component"= 3), inline = FALSE)
div(style = "display: inline-block; width: 150px;", numericInput(inputId = "cutoff",  label = h6("Pvalue cutoff"), value = 0, min = 0, max = 20, step = 0.01 , width = '100%'))
div(style = "display: inline-block; width: 150px;",  numericInput(inputId = "qcutoff",  label = h6("q-value cutoff ORA"), value = 0, min = 0, max = 20, step = 0.01, width = '100%'))
selectInput(inputId = "pA_method", label = h5(strong("pAdjust Method")), choices = c("None" =1, "holm" = 2, "hochberg"= 3, "hommel"= 4, "bonferroni"= 5, "Benjamini & Hochberg(BH)" = 6, "Benjamini & Yekutieli(BY)" = 7, "fdr" = 8 ))
checkboxGroupInput(inputId = "checkbox_GSE_GO", label = h5(strong("Enrichment analysis method")), choices = list("GO ORA",  "GO GSEA"), inline = TRUE)
actionButton(inputId = "submit_GO", "Go!")
checkboxGroupInput(inputId = "heatmapT1_table", label = h5(strong("Download GO result")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"),inline = TRUE)
downloadButton(inputId = "GO_result", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")


downloadHandler(
filename = function(){
if (input$heatmapT1_table == "Treatment-1")
{paste("GO result treatment1", ".csv", sep = "")}
else if (input$heatmapT1_table == "Treatment-2")
{paste("GO result treatment2", ".csv", sep = "")}
else if (input$heatmapT1_table == "Treatment-3")
{paste("GO result treatment3", ".csv",  sep = "")}
else if (input$heatmapT1_table == "Treatment-4")
{paste("GO result treatment4", ".csv",  sep = "")}
},
content = function(file){
if (input$heatmapT1_table == "Treatment-1") {
write.csv(GO_final_table_1(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-2"){
write.csv(GO_final_table_2(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-3") {
write.csv(GO_final_table_3(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-4") {
write.csv(GO_final_table_4(), file, row.names = FALSE)
}
})
```

## Column {.tabset}

### Ontology result-1

```{r, echo= FALSE}
onto_1 <- reactive({
if (input$select_GO == 1) {ontology_1 <- "BP"} 
else if (input$select_GO == 2) {ontology_1 <- "MF"}
else if (input$select_GO == 3) {ontology_1 <- "CC"}
})
Org_database_1 <- reactive({
if (input$select1 == 1) {org.Hs.eg.db} 
else if (input$select1 == 2) {org.Gg.eg.db}
else if (input$select1 == 3) {org.Ss.eg.db}
else if (input$select1 == 4) {org.Bt.eg.db}
})
adjust_method_1 <- reactive({
if (input$pA_method == 1) { PAdjust <- "none"}
else if (input$pA_method == 2) {PAdjust <-"holm"} 
else if (input$pA_method == 3) {PAdjust <-"hochberg"} 
else if (input$pA_method == 4) {PAdjust <-"hommel"} 
else if (input$pA_method == 5) {PAdjust <-"bonferroni"} 
else if (input$pA_method == 6) {PAdjust <-"BH"} 
else if (input$pA_method == 7) {PAdjust <-"BY"} 
else if (input$pA_method == 8) {PAdjust <-"fdr"} 
})

GO_table_001 <- reactive({
if(input$select_omics == "Transcriptomics"){
df_with_Etzgene <- getBM(attributes = c("entrezgene_id", 'ensembl_gene_id', "external_gene_name"), filters = "ensembl_gene_id",  values = datasetInput(), mart = data_list_1())
}
else if (input$select_omics == "Proteomics") {
df_with_Etzgene_pro <- getBM(attributes = c("entrezgene_id", "uniprotswissprot", "external_gene_name"), filters = "uniprotswissprot",  values = datasetInput1(), mart = data_list_1())
}
})

GO_table_1 <- reactive({
if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
clusterProfiler::enrichGO(gene = as.vector(GO_merge$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)}     
  
else if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
df_with_Etzgene_1_1 <- GO_table_001()
GO_merge_prot_1 <- merge(df_3_1(), df_with_Etzgene_1_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
GO_prot_1 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_prot_1$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)  
  }  
 })


#for gene set enrichment ontology treatment 1
GO_gse_table_1 <- reactive({
if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
df_3 <- as.data.frame(Filtertable1())  
df_3 <- df_3[, c(1, 2)]
GSEgo_list <- df_3[, 2]
names(GSEgo_list) <- as.character(df_3[, 1])
GSEgo_list <- sort(GSEgo_list, decreasing = TRUE)
clusterProfiler::gseGO(geneList = GSEgo_list, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1, eps = 1e-10,  keyType = "ENSEMBL", by = "fgsea") }    

else if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
df_3_pro_1 <- df_3_1()
df_3_pro_1 <- df_3_pro_1[, c(1, 3)]
GSEgo_pro_list <- df_3_pro_1[, 2]
names(GSEgo_pro_list) <- as.character(df_3_pro_1[, 1])
GSEgo_pro_list <- sort(GSEgo_pro_list, decreasing = TRUE)
clusterProfiler::gseGO(geneList = GSEgo_pro_list, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1, eps = 1e-10,  keyType = "UNIPROT",  by = "fgsea")
  } 
})

GO_final_table_1 <- eventReactive(input$submit_GO, {
withProgress(message = "Fetching gene ontology terms from database for treatment-1", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}
GO_001 <- isolate(if (input$checkbox_GSE_GO == "GO GSEA"){
(GO_gse_table_1()@result)}
else if (input$checkbox_GSE_GO == "GO ORA"){
 (GO_table_1()@result)}
)
GO_001
})
})


output$GO_table_GO <- DT::renderDataTable({
validate(need(input$select_GO != "", "Please select gene ontology term to perform gene ontology enrichment analysis."),
need(input$checkbox_GSE_GO != "", "Please select enrichment method for gene ontology analysis."),
need(input$submit_GO != "", "Please select submit button to perform gene ontology enrichment analysis!")
)
GO_final_table_1()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))
DT::dataTableOutput("GO_table_GO")


### data modification for heatmap
heatmap_plot_data <- reactive({
Selected_data <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(GO_table_1()@result)
selected_rows <- reactive({
GO_rows <- input$GO_table_GO_rows_selected
Selected_data_1[sort(GO_rows), ]
})

Heatmap_data <- as.data.frame(selected_rows())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data[, c(2, 8)]
#separate gene id by /
GO_separated_gene <- separate_rows(Heat_data_1, "geneID", sep = "/", convert = TRUE)
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 


if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
H_data_filtered <- as.data.frame(Filtertable1())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- H_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge <- HTmap_merge[, c(2,4)]
h_1_heatmap <- inner_join(x = GO_separated_gene, y = new_h1_heat_merge, by = c("geneID" ="external_gene_name")) %>% unique()
}

else if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
H_data_filtered <- Filtertable1_1()
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- H_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge <- HTmap_merge[, c(2,4)]
h_1_heatmap <- inner_join(x = GO_separated_gene, y = new_h1_heat_merge, by = c("geneID" ="external_gene_name")) %>% unique()
}
})

#data preparation for gsea heatmap
heatmap_plot_data_gsea <- reactive({
#all uploaded file data with different ids  
Selected_data_gse <- as.data.frame(GO_table_001()) 
Selected_data_1_gse <- as.data.frame(GO_gse_table_1()@result)
selected_rows_gse_1 <- reactive({
GO_rows <- input$GO_table_GO_rows_selected
Selected_data_1_gse[sort(GO_rows), ]
})

Heatmap_data_gse <- as.data.frame(selected_rows_gse_1())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data_gse[, c(2, 11)]
#separate gene id by /
GO_separated_gene_gse <- separate_rows(Heat_data_1, "core_enrichment", sep = "/", convert = TRUE)


if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
H_data_filtered <- as.data.frame(Filtertable1())
'this dataframe can be used for the conversion of first column to gene name (ensembl and logfc from filtered data'
Heat_data_2 <- H_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]
h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by = c("core_enrichment" ="ENSEMBLGENE")) %>% unique()
h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)]
}

else if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
H_data_filtered <- Filtertable1_1()
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- H_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]
h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by =  c("core_enrichment" = "UniProt ID")) %>% unique()
h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)]
}
})

```

### Ontology result-2

```{r, echo= FALSE}
GO_table_2 <-  reactive({
if (c("GO ORA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){  
df_4 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_2 <- merge(df_4, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
GO_output_result_1 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_2$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff, pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)}
  
else if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
df_with_Etzgene_1_1 <- GO_table_001()
GO_merge_prot_2 <- merge(df_4_1(), df_with_Etzgene_1_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
GO_prot_2 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_prot_2$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)  
  }  
})

#for gene set enrichment ontology treatment 2
GO_gse_table_2 <- reactive({
if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){ 
df_4 <- as.data.frame(Filtertable2())  
df_4 <- df_4[, c(1, 2)]
GSEgo_list_2 <- df_4[, 2]
names(GSEgo_list_2) <- as.character(df_4[, 1])
GSEgo_list_2 <- sort(GSEgo_list_2, decreasing = TRUE)
GO_output_result_gse_go_2 <- clusterProfiler::gseGO(geneList = GSEgo_list_2, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "ENSEMBL", by = "fgsea")}
  

else if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
df_3_pro_2 <- df_4_1()
df_3_pro_2 <- df_3_pro_2[, c(1, 3)]
GSEgo_pro_list <- df_3_pro_2[, 2]
names(GSEgo_pro_list) <- as.character(df_3_pro_2[, 1])
GSEgo_pro_list <- sort(GSEgo_pro_list, decreasing = TRUE)
clusterProfiler::gseGO(geneList = GSEgo_pro_list, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "UNIPROT", by = "fgsea")
  }   
})


GO_final_table_2 <- eventReactive(input$submit_GO,{
withProgress(message = "Fetching gene ontology terms from database for treatment-2", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}
GO_002 <- isolate(if (input$checkbox_GSE_GO == "GO ORA"){
as.data.frame(GO_table_2()@result)}
else if (input$checkbox_GSE_GO == "GO GSEA"){
as.data.frame(GO_gse_table_2()@result)}
)
GO_002
})
})

output$GO_table_GO_2 <- DT::renderDataTable({
validate(
need(input$select_GO != "", "Please select gene ontology term to perform gene ontology enrichment analysis."),
need(input$checkbox_GSE_GO != "", "Please select enrichment method for gene ontology analysis!"))  
GO_final_table_2()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))
DT::dataTableOutput("GO_table_GO_2")


#heatmap data preparation for ORA
heatmap_plot_data_2 <- reactive({
Selected_data <- as.data.frame(GO_table_001())
Selected_data_2 <- as.data.frame(GO_table_2()@result)
selected_rows_2 <- reactive({GO_rows <- input$GO_table_GO_2_rows_selected
Selected_data_2[sort(GO_rows), ]})
Heatmap_data_2 <- as.data.frame(selected_rows_2())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_2 <- Heatmap_data_2[, c(2, 8)]
#separate gene id by /
GO_separated_gene_2 <- separate_rows(Heat_data_2, "geneID", sep = "/", convert = TRUE)

'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
H_data_filtered_2 <- as.data.frame(Filtertable2())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_3 <- H_data_filtered_2[, c(1, 2)]
HTmap_merge_2 <- merge(x = Heat_data_3, y = Selected_data, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_2 <- HTmap_merge_2[, c(2,4)]
h_1_heatmap_2 <- inner_join(x = GO_separated_gene_2, y = new_h1_heat_merge_2, by = c("geneID" ="external_gene_name")) %>% unique()
}

else if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
H_data_filtered <- df_4_1()
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- H_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_2 <- HTmap_merge[, c(2,4)]
h_1_heatmap <- inner_join(x = GO_separated_gene_2, y = new_h1_heat_merge_2, by = c("geneID" ="external_gene_name")) %>% unique()  
}
})

#Data preparation for gsea heatmap treatment 2
heatmap_plot_data_gsea_2 <- reactive({
#all uploaded file data with different ids  
Selected_data_gse <- as.data.frame(GO_table_001()) 
Selected_data_2_gse <- as.data.frame(GO_gse_table_2()@result)
selected_rows_gse_2 <- reactive({
GO_rows <- input$GO_table_GO_2_rows_selected
Selected_data_2_gse[sort(GO_rows), ]
})
Heatmap_data_gse <- as.data.frame(selected_rows_gse_2())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data_gse[, c(2, 11)]
#separate gene id by /
GO_separated_gene_gse <- separate_rows(Heat_data_1, "core_enrichment", sep = "/", convert = TRUE)

'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
H_data_filtered <- as.data.frame(Filtertable2())
'this dataframe can be used for the conversion of first column to gene name (ensembl and logfc from filtered data'
Heat_data_2 <- H_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]
h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by = c("core_enrichment" ="ENSEMBLGENE")) %>% unique()
h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)] 
}

else if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
H_data_filtered <- df_4_1()
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- H_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]
h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by =  c("core_enrichment" = "UniProt ID")) %>% unique()
h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)]
}
})
```

### Ontology result-3

```{r, echo= FALSE}
#for ORA GO production
GO_table_3 <-  reactive({
if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){  
df_5 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_3 <- merge(df_5, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
GO_output_result_1 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_3$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)}

else if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
df_with_Etzgene_1_1 <- GO_table_001()
GO_merge_prot_3 <- merge(df_5_1(), df_with_Etzgene_1_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
GO_prot_3 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_prot_3$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)  
  }    
  
})


#for gene set enrichment ontology treatment 3
GO_gse_table_3 <- reactive({
if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
df_5 <- as.data.frame(Filtertable3())  
df_5 <- df_5[, c(1, 2)]
GSEgo_list_3 <- df_5[, 2]
names(GSEgo_list_3) <- as.character(df_5[, 1])
GSEgo_list_3 <- sort(GSEgo_list_3, decreasing = TRUE)
GO_output_result_gse_go_3 <- clusterProfiler::gseGO(geneList = GSEgo_list_3, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "ENSEMBL", by = "fgsea")}

else if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
df_3_pro_3 <- df_5_1()
df_3_pro_3 <- df_3_pro_3[, c(1, 3)]
GSEgo_pro_list <- df_3_pro_3[, 2]
names(GSEgo_pro_list) <- as.character(df_3_pro_3[, 1])
GSEgo_pro_list <- sort(GSEgo_pro_list, decreasing = TRUE)
clusterProfiler::gseGO(geneList = GSEgo_pro_list, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "UNIPROT", by = "fgsea")
}     
  })


GO_final_table_3 <- eventReactive(input$submit_GO,{
withProgress(message = "Fetching gene ontology terms from database for treatment-3", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}
GO_003 <- isolate(if (input$checkbox_GSE_GO == "GO ORA"){
as.data.frame(GO_table_3()@result)}
else if (input$checkbox_GSE_GO == "GO GSEA"){
as.data.frame(GO_gse_table_3()@result)}
)
GO_003
})
})
output$GO_table_GO_3 <- DT::renderDataTable({
validate(
need(input$select_GO != "", "Please select gene ontology term to perform gene ontology enrichment analysis."),
need(input$checkbox_GSE_GO != "", "Please select enrichment method for gene ontology analysis."))  
GO_final_table_3()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))
DT::dataTableOutput("GO_table_GO_3")


#heatmap data preparation for ORA
heatmap_plot_data_3 <- reactive({
Selected_data <- as.data.frame(GO_table_001())
Selected_data_3 <- as.data.frame(GO_table_3()@result)
selected_rows_3 <- reactive({GO_rows <- input$GO_table_GO_3_rows_selected
Selected_data_3[sort(GO_rows), ]})
Heatmap_data_3 <- as.data.frame(selected_rows_3())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_3 <- Heatmap_data_3[, c(2, 8)]
#separate gene id by /
GO_separated_gene_3 <- separate_rows(Heat_data_3, "geneID", sep = "/", convert = TRUE)


'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
H_data_filtered_3 <- as.data.frame(Filtertable3())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_4 <- H_data_filtered_3[, c(1, 2)]
HTmap_merge_3 <- merge(x = Heat_data_4, y = Selected_data, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_3 <- HTmap_merge_3[, c(2,4)]
h_1_heatmap_3 <- inner_join(x = GO_separated_gene_3, y = new_h1_heat_merge_3, by = c("geneID" ="external_gene_name")) %>% unique()
}

else if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
H_data_filtered <- df_5_1()
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- H_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_2 <- HTmap_merge[, c(2,4)]
h_1_heatmap <- inner_join(x = GO_separated_gene_3, y = new_h1_heat_merge_2, by = c("geneID" ="external_gene_name")) %>% unique()  
}
})

#data preparation for gsea heatmap treatment 3
heatmap_plot_data_gsea_3 <- reactive({
#all uploaded file data with different ids  
Selected_data_gse <- as.data.frame(GO_table_001()) 
Selected_data_3_gse <- as.data.frame(GO_gse_table_3()@result)
selected_rows_gse_3 <- reactive({
GO_rows <- input$GO_table_GO_3_rows_selected
Selected_data_3_gse[sort(GO_rows), ]
})
Heatmap_data_gse <- as.data.frame(selected_rows_gse_3())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data_gse[, c(2, 11)]
#separate gene id by /
GO_separated_gene_gse <- separate_rows(Heat_data_1, "core_enrichment", sep = "/", convert = TRUE)

'this is the uploaded data that will be used for the fetching of logfc value of the gene' 

if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
H_data_filtered <- as.data.frame(Filtertable3())
'this dataframe can be used for the conversion of first column to gene name (ensembl and logfc from filtered data'
Heat_data_2 <- H_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]
h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by = c("core_enrichment" ="ENSEMBLGENE")) %>% unique()
h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)] 
}

else if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
H_data_filtered <- df_5_1()
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- H_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]
h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by =  c("core_enrichment" = "UniProt ID")) %>% unique()
h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)]
}
})
```

### Ontology result-4

```{r, echo= FALSE}
GO_table_4 <- reactive({
if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){    
df_6 <- as.data.frame(Filtertable4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_4 <- merge(df_6, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
GO_output_result_1 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_4$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)}


else if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
df_with_Etzgene_1_1 <- GO_table_001()
GO_merge_prot_4 <- merge(df_6_1(), df_with_Etzgene_1_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
GO_prot_4 <- clusterProfiler::enrichGO(gene = as.vector(GO_merge_prot_4$entrezgene_id), OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, qvalueCutoff = input$qcutoff,  pAdjustMethod = adjust_method_1(), readable = TRUE, minGSSize = 1)  
  }
})

#for gene set enrichment ontology treatment 4
GO_gse_table_4 <- reactive({
if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){  
df_6 <- as.data.frame(Filtertable4())  
df_6 <- df_6[, c(1, 2)]
GSEgo_list_4 <- df_6[, 2]
names(GSEgo_list_4) <- as.character(df_6[, 1])
GSEgo_list_4 <- sort(GSEgo_list_4, decreasing = TRUE)
GO_output_result_gse_go_4 <- clusterProfiler::gseGO(geneList = GSEgo_list_4, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "ENSEMBL", by = "fgsea")}

else if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
df_3_pro_4 <- df_6_1()
df_3_pro_4 <- df_3_pro_4[, c(1, 3)]
GSEgo_pro_list <- df_3_pro_4[, 2]
names(GSEgo_pro_list) <- as.character(df_3_pro_4[, 1])
GSEgo_pro_list <- sort(GSEgo_pro_list, decreasing = TRUE)
clusterProfiler::gseGO(geneList = GSEgo_pro_list, OrgDb = Org_database_1(), ont = onto_1(), pvalueCutoff = input$cutoff, pAdjustMethod = adjust_method_1(), minGSSize = 1,  nPerm = 1000, keyType = "UNIPROT", by = "fgsea")
}    
  })

GO_final_table_4 <- eventReactive(input$submit_GO, { 
withProgress(message = "Fetching gene ontology terms from database for treatment-4", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}
GO_004 <- isolate(if (input$checkbox_GSE_GO == "GO ORA"){
as.data.frame(GO_table_4()@result)}
else if (input$checkbox_GSE_GO == "GO GSEA"){
as.data.frame(GO_gse_table_4()@result)}
)
GO_004
})
})

output$GO_table_GO_4 <- DT::renderDataTable({
validate(
need(input$select_GO != "", "Please select gene ontology term to perform gene ontology enrichment analysis!"),
need(input$checkbox_GSE_GO != "", "Please select enrichment method for gene ontology analysis."))
GO_final_table_4()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))
DT::dataTableOutput("GO_table_GO_4")

#data preparation for heatmap ora4
heatmap_plot_data_4 <- reactive({
Selected_data <- as.data.frame(GO_table_001())
Selected_data_4 <- as.data.frame(GO_table_4()@result)
selected_rows_4 <- reactive({GO_rows <- input$GO_table_GO_4_rows_selected
Selected_data_4[sort(GO_rows), ]})
Heatmap_data_4 <- as.data.frame(selected_rows_4())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_4 <- Heatmap_data_4[, c(2, 8)]
#separate gene id by /
GO_separated_gene_4 <- separate_rows(Heat_data_4, "geneID", sep = "/", convert = TRUE)

if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
H_data_filtered_4 <- as.data.frame(Filtertable4())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_5 <- H_data_filtered_4[, c(1, 2)]
HTmap_merge_4 <- merge(x = Heat_data_5, y = Selected_data, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_4 <- HTmap_merge_4[, c(2,4)]
h_1_heatmap_4 <- inner_join(x = GO_separated_gene_4, y = new_h1_heat_merge_4, by = c("geneID" ="external_gene_name")) %>% unique()
}

else if(c("GO ORA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
H_data_filtered <- df_6_1()
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- H_data_filtered[, c(1,3)]
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns external_gene_name and logFc to merge with the gene ontology output
new_h1_heat_merge_2 <- HTmap_merge[, c(2,4)]
h_1_heatmap <- inner_join(x = GO_separated_gene_4, y = new_h1_heat_merge_2, by = c("geneID" ="external_gene_name")) %>% unique()  
}
})

#data preparation for gsea heatmap treatment 4
heatmap_plot_data_gsea_4 <- reactive({
#all uploaded file data with different ids  
Selected_data_gse <- as.data.frame(GO_table_001()) 
Selected_data_4_gse <- as.data.frame(GO_gse_table_4()@result)
selected_rows_gse_2 <- reactive({
GO_rows <- input$GO_table_GO_4_rows_selected
Selected_data_4_gse[sort(GO_rows), ]
})

Heatmap_data_gse <- as.data.frame(selected_rows_gse_2())
#columns selected from the Gene ontology output with gene description and geneID
Heat_data_1 <- Heatmap_data_gse[, c(2, 11)]
#separate gene id by /
GO_separated_gene_gse <- separate_rows(Heat_data_1, "core_enrichment", sep = "/", convert = TRUE)
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 


if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Transcriptomics" %in% input$select_omics_GO)){
H_data_filtered <- as.data.frame(Filtertable4())
'this dataframe can be used for the conversion of first column to gene name (ensembl and logfc from filtered data'
Heat_data_2 <- H_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]
h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by = c("core_enrichment" ="ENSEMBLGENE")) %>% unique()
h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)] 
}

else if(c("GO GSEA" %in% input$checkbox_GSE_GO) && ("Proteomics" %in% input$select_omics_GO)){
H_data_filtered <- df_6_1()
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- H_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logFC to merge with the gene ontology output
HTmap_merge <- merge(x = Heat_data_2, y = Selected_data_gse, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns external_gene_name and logFC to merge with the gene ontology output
new_h1_heat_merge_gse <- HTmap_merge[, c(1,2,4)]
h_1_heatmap_gse <- inner_join(x = GO_separated_gene_gse, y = new_h1_heat_merge_gse, by =  c("core_enrichment" = "UniProt ID")) %>% unique()
h_1_heatmap_gse_final <- h_1_heatmap_gse[, c(1, 4, 3)]
}
})

output$GO_result <- downloadHandler(
filename = function(){
if (input$heatmapT1_table == "Treatment-1")
{paste("GO result treatment1", Sys.Date(), ".csv", sep = "")}
else if (input$heatmapT1_table == "Treatment-2")
{paste("GO result treatment2", Sys.Date(), ".csv", sep = "")}
else if (input$heatmapT1_table == "Treatment-3")
{paste("GO result treatment3", Sys.Date(), ".csv",  sep = "")}
else if (input$heatmapT1_table == "Treatment-4")
{paste("GO result treatment4", Sys.Date(), ".csv",  sep = "")}
},
content = function(file){
if (input$heatmapT1_table == "Treatment-1") {
write.csv(GO_final_table_1(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-2"){
write.csv(GO_final_table_2(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-3") {
write.csv(GO_final_table_3(), file, row.names = FALSE)
}else if (input$heatmapT1_table == "Treatment-4") {
write.csv(GO_final_table_4(), file, row.names = FALSE)
}
})
```

# GO heatmaps

## Sidebar {.sidebar data-width="350"}

```{r, echo=FALSE}
checkboxGroupInput(inputId = "checkbox_heatmap_GO", label = h5(strong("Heatmap visualization")), choices = list("GO ORA",  "GO GSEA"), inline = TRUE)
checkboxGroupInput(inputId = "heatmapT1", label = h5(strong("Treatments")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"),inline = TRUE)
fluidRow(column(4, numericInput( inputId = "heatmap_input1",  label = h6("col text size"), value = 1.2, min = 0.1, max = 10, step = 0.1, width = '100%')),
column (4, numericInput( inputId = "heatmap_input2",  label = h6("row text size"), value = 1.2, min = 0.1, max = 10, step = 0.1, width = '100%')),
column (4, numericInput( inputId = "heatmap_input3",  label = h6("color key size"), value = 0.4, min = 0.1, max = 10, step = 0.1, width = '100%')))
textInput(inputId = "heat_text", label = h5(strong("Title for heatmap")), value = "")
selectInput(inputId = "select_format_GO", label = h5(strong("Format")), choices = c("jpeg", "png", "pdf", "tiff"))
fluidRow(column (4, numericInput( inputId = "Download_heat_input1",  label = h6("Plot width"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_heat_input2",  label = h6("Plot height"), value = 20, min = 10, max = 50, step = 10, width = '100%')),
column (4, numericInput( inputId = "Download_heat_input3",  label = h6("Plot resolution"), value = 300, min = 10, max = 500, step = 50, width = '100%')))
downloadButton(inputId = "Download_heat_map", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")
downloadHandler(
filename = function(){paste0("heatmap", sep = ".", input$select_format_GO)},
content = function(file){
if (input$select_format_GO == "jpeg"){
jpeg(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}
else if (input$select_format_GO == "png"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}
else if (input$select_format_GO == "pdf"){
pdf(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}
  
else if (input$select_format_GO == "tiff"){
tiff(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}  
  })

h5(strong("Visualization of Ontology"))
fluidRow(column(4,checkboxGroupInput(inputId = "checkbox_4", label = "", choices = list("Word Cloud"), inline = TRUE)),
column(4,numericInput( inputId = "wordcloud_input1",  label = h6("max.words"), value = 100, min = 10, max = 500, step = 50, width = '100%')))
                
downloadButton(inputId = "downloadwordcloud", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")
downloadHandler(
filename = function(){paste0("wordcloud", sep=".", input$select_format_GO)
},
content = function(file){
if (input$select_format_GO == "jpeg"){
jpeg(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}
else if (input$select_format_GO == "png"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}
else if (input$select_format_GO == "pdf"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}
  
else if (input$select_format_GO == "tiff"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}  
  
})
```

## Column {.tabset}

### Heatmaps

```{r, echo=FALSE}
# these code for GSEA heatmap
heatmap_gse_1 <- reactive({
if(input$checkbox_heatmap_GO == "GO GSEA"){
h_plot_data_gse_1 <- as.data.frame(heatmap_plot_data_gsea())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(2, 3)]
names(h_plot_gse_1_1)[2] <- as.character(h_plot_data_gse_1[[1, 1]])
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
}
})

heatmap_gse_12 <- reactive({
if (input$checkbox_heatmap_GO == "GO GSEA"){  
h_plot_data_gse_2 <- as.data.frame(heatmap_plot_data_gsea_2())
h_plot_gse_2_2 <- h_plot_data_gse_2[, c(2, 3)]
names(h_plot_gse_2_2)[2] <- as.character(h_plot_data_gse_2[[1, 1]])
heatmap_f1 <- merge(heatmap_gse_1(), h_plot_gse_2_2, by.y = "external_gene_name", by.x = "external_gene_name", all = TRUE, suffixes = c("", ""))
heatmap_f2 <- heatmap_f1[!duplicated(heatmap_f1[["external_gene_name"]]), ]
heatmap_f2
heatmap_f1[heatmap_f1 == " "] <- NA
as.data.frame(heatmap_f1)
heatmap_f3 <- na.omit(heatmap_f2)
heatmap_f3
}
})

heatmap_gse_13 <- reactive({
if (input$checkbox_heatmap_GO == "GO GSEA"){   
h_plot_data_gse_2 <- as.data.frame(heatmap_plot_data_gsea_3())
h_plot_gse_2_2 <- h_plot_data_gse_2[, c(2, 3)]
names(h_plot_gse_2_2)[2] <- as.character(h_plot_data_gse_2[[1, 1]])
heatmap_f1 <- merge(heatmap_gse_12(), h_plot_gse_2_2, by.y = "external_gene_name", by.x = "external_gene_name", all = TRUE, suffixes = c("", ""))
heatmap_f2 <- heatmap_f1[!duplicated(heatmap_f1[["external_gene_name"]]), ]
heatmap_f2
heatmap_f1[heatmap_f1 == " "] <- NA
as.data.frame(heatmap_f1)
heatmap_f3 <- na.omit(heatmap_f2)
heatmap_f3
}
})

heatmap_gse_14 <- reactive({
if (input$checkbox_heatmap_GO == "GO GSEA"){  
h_plot_data_gse_2 <- as.data.frame(heatmap_plot_data_gsea_4())
h_plot_gse_2_2 <- h_plot_data_gse_2[, c(2, 3)]
names(h_plot_gse_2_2)[2] <- as.character(h_plot_data_gse_2[[1, 1]])
heatmap_f1 <- merge(heatmap_gse_13(), h_plot_gse_2_2, by.y = "external_gene_name", by.x = "external_gene_name", all = TRUE, suffixes = c("", ""))
heatmap_f2 <- heatmap_f1[!duplicated(heatmap_f1[["external_gene_name"]]), ]
heatmap_f2
heatmap_f1[heatmap_f1 == " "] <- NA
as.data.frame(heatmap_f1)
heatmap_f3 <- na.omit(heatmap_f2)
heatmap_f3
}
})

heatmap_11 <- reactive({
if (all(c("Treatment-1", "Treatment-2") %in% input$heatmapT1)){
heatmap_f3 <- heatmap_gse_12()
rownames(heatmap_f3) <- NULL
heatmap_f5 <- column_to_rownames(.data = heatmap_f3,  var = "external_gene_name")
heatmap_22 <- as.matrix(heatmap_f5)
rlm <- rainbow(ncol(heatmap_22))
heatmap.2(heatmap_22, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none",  margins = c(3,22), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,) 
legend("topright", legend = c("Treatment-1", "Treatment-2"), col = rlm, lty= 1,lwd = 8,bty = "n")
}
  
if (all(c("Treatment-1", "Treatment-3") %in% input$heatmapT1)){
heatmap_f3 <- as.data.frame(heatmap_gse_13())
rownames(heatmap_f3) <- NULL
heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "external_gene_name")
heatmap_22 <- as.matrix(heatmap_f5)
rlm <- rainbow(ncol(heatmap_22))
heatmap.2(heatmap_22, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none",  margins = c(3,22), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,) 
legend("topright", legend = c("Treatment-1", "Treatment-2", "Treatment-3"), col = rlm, lty= 1,lwd = 8,bty = "n")
}

if (all(c("Treatment-1", "Treatment-4") %in% input$heatmapT1)){
heatmap_f3 <- as.data.frame(heatmap_gse_14())
rownames(heatmap_f3) <- NULL
heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "external_gene_name")
heatmap_22 <- as.matrix(heatmap_f5)
rlm <- rainbow(ncol(heatmap_22))
heatmap.2(heatmap_22, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none",  margins = c(3,22), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,) 
legend("topright", legend = c("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"), col = rlm, lty= 1,lwd = 8,bty = "n")}
})


heatmap_ora_11 <- reactive({
if (input$checkbox_heatmap_GO == "GO ORA"){  
h_plot_data <- as.data.frame(heatmap_plot_data())
h_plot_data_1_1 <- h_plot_data[, c(2, 3)]
names(h_plot_data_1_1)[2] <- as.character(h_plot_data[[1, 1]])
heatmap_f_try <- as.data.frame(replace(h_plot_data_1_1, is.na(h_plot_data_1_1), 0))
}
})
heatmap_ora_12 <- reactive({
if (input$checkbox_heatmap_GO == "GO ORA"){
h_plot_data_2 <- as.data.frame(heatmap_plot_data_2())
h_plot_data_2_2 <- h_plot_data_2[, c(2, 3)]
names(h_plot_data_2_2)[2] <- as.character(h_plot_data_2[[1, 1]])
heatmap_f2 <- merge(heatmap_ora_11(), h_plot_data_2_2, by.y = "geneID", by.x = "geneID", all = TRUE, suffixes = c("", ""))
heatmap_f3 <- as.data.frame(replace(heatmap_f2, is.na(heatmap_f2), 0))
}
})
heatmap_ora_13 <- reactive({
if (input$checkbox_heatmap_GO == "GO ORA"){  
h_plot_data_3 <- as.data.frame(heatmap_plot_data_3())
h_plot_data_3_3 <- h_plot_data_3[, c(2, 3)]
names(h_plot_data_3_3)[2] <- as.character(h_plot_data_3[[1, 1]])
heatmap_f2 <- merge(heatmap_ora_12(), h_plot_data_3_3, by.y = "geneID", by.x = "geneID", all = TRUE, suffixes = c("", ""))
heatmap_f3 <- as.data.frame(replace(heatmap_f2, is.na(heatmap_f2), 0))
}
})

heatmap_ora_14 <- reactive({
if (input$checkbox_heatmap_GO == "GO ORA"){  
h_plot_data_4 <- as.data.frame(heatmap_plot_data_4())
h_plot_data_4_4 <- h_plot_data_4[, c(2, 3)]
names(h_plot_data_4_4)[2] <- as.character(h_plot_data_4[[1, 1]])
heatmap_f2 <- merge(heatmap_ora_13(), h_plot_data_4_4, by.y = "geneID", by.x = "geneID", all = TRUE, suffixes = c("", ""))
heatmap_f3 <- as.data.frame(replace(heatmap_f2, is.na(heatmap_f2), 0))
}
})

heatmap_12 <- reactive({
if (all(c("Treatment-1", "Treatment-2") %in% input$heatmapT1)){
heatmap_f3 <- as.data.frame(heatmap_ora_12()) 
heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "geneID") %>% unique()
heatmap_ora_1_1 <- as.matrix(heatmap_f5)
rlm <- rainbow(ncol(heatmap_ora_1_1))
heatmap.2(heatmap_ora_1_1, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none", margins = c(3,30), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0) 
legend("topright", legend = c("Treatment-1", "Treatment-2"), col = rlm, lty= 1,lwd = 5, bty = "n")
}

else if (all(c("Treatment-1", "Treatment-3" ) %in% input$heatmapT1)) {
heatmap_f3 <- as.data.frame(heatmap_ora_13())  
heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "geneID")
heatmap_ora_1_1 <- as.matrix(heatmap_f5)
rlm <- rainbow(ncol(heatmap_ora_1_1))
heatmap.2(heatmap_ora_1_1, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none", margins = c(2,20), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,)
legend("topright", legend = c("Treatment-1", "Treatment-2", "Treatment-3"), col = rlm, lty= 1,lwd = 5,bty = "n")
}
else if (all(c("Treatment-1", "Treatment-4" ) %in% input$heatmapT1)) {
heatmap_f3 <- as.data.frame(heatmap_ora_14())
heatmap_f5 <- column_to_rownames(.data = heatmap_f3, var = "geneID")
heatmap_ora_1_1 <- as.matrix(heatmap_f5)
rlm <- rainbow(ncol(heatmap_ora_1_1))
heatmap.2(heatmap_ora_1_1, ColSideColors = rlm, main = input$heat_text, keysize = input$heatmap_input3, key.title = NA, key.xlab = NA, key.ylab = NA, dendrogram = "none", col = redgreen(255), Rowv = FALSE, Colv = FALSE, key = TRUE, trace = "none", margins = c(3,22), cexCol = input$heatmap_input1, cexRow = input$heatmap_input2, srtCol = 0, adjCol = c(0.5, 0), offsetRow = 0,) 
legend("topright", legend = c("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"), col = rlm, lty= 1,lwd = 8,bty = "n")
}
})
final_heat_map_plot <- reactive({
if (input$checkbox_heatmap_GO == "GO GSEA") {heatmap_11()}
else if (input$checkbox_heatmap_GO == "GO ORA"){heatmap_12()}
p1 <- recordPlot()  
  })


final_gse_table <- reactive({
if (c("Treatment-2" %in% input$heatmapT1) && ("GO GSEA" %in% input$checkbox_heatmap_GO))
{heatmap_gse_12()}
else if (c("Treatment-3" %in% input$heatmapT1) &&  ("GO GSEA" %in% input$checkbox_heatmap_GO))
{heatmap_gse_13()}
else if (c("Treatment-4" %in% input$heatmapT1) &&  ("GO GSEA" %in% input$checkbox_heatmap_GO))
{heatmap_gse_14()} 
else if (c("Treatment-2" %in% input$heatmapT1) &&  ("GO ORA" %in% input$checkbox_heatmap_GO))
{heatmap_ora_12()}   
else if (c("Treatment-3" %in% input$heatmapT1) &&  ("GO ORA" %in% input$checkbox_heatmap_GO))
{heatmap_ora_13()} 
else if (c("Treatment-4" %in% input$heatmapT1) &&  ("GO ORA" %in% input$checkbox_heatmap_GO))
{heatmap_ora_14()}
  
})

output$heatmap_16 <- renderPlot({
validate(need(input$checkbox_heatmap_GO != "", "Please select heatmap visualization for heatmap construction."),
need(input$heatmapT1 != "", "Please select the treatment to generate heatmap visualization."))  
if(input$heatmapT1 > 0){
withProgress(message = "Heatmap prodution of Gene ontology",  detail = "Constructing heatmap according to the row selection in GO analysis.", value = 0,
{
for(i in 1:10)
{incProgress(1/15)
 Sys.sleep(0.1)}  
final_heat_map_plot()})
}
})
plotOutput("heatmap_16")
```

### GO word cloud

```{r, echo=FALSE}
set.seed(1234)

GO_word_cloud_ora <- eventReactive(input$checkbox_4, {
if(input$heatmapT1 == "Treatment-1" ){
wordcloud::wordcloud(words = GO_final_table_1()[, 2], freq = GO_final_table_1()[, 9], min.freq = 1, colors = brewer.pal(8, "Dark2"), random.color = FALSE, scale = c(3, 0.4),  max.words = input$wordcloud_input1) }
else if(input$heatmapT1 == "Treatment-2" ){
wordcloud::wordcloud(words = GO_final_table_2()[, 2], freq = GO_final_table_2()[, 9], min.freq = 1, colors = brewer.pal(8, "Dark2"), random.color = FALSE, scale = c(3, 0.4),  max.words = input$wordcloud_input1)}
else if(input$heatmapT1 == "Treatment-3" ){
wordcloud::wordcloud(words = GO_final_table_3()[, 2], freq = GO_final_table_3()[, 9], min.freq = 1, colors = brewer.pal(8, "Dark2"), random.color = FALSE, scale = c(3, 0.4),  max.words = input$wordcloud_input1)}
else if(input$heatmapT1 == "Treatment-4"){
wordcloud::wordcloud(words = GO_final_table_4()[, 2], freq = GO_final_table_4()[, 9], min.freq = 1, colors = brewer.pal(8, "Dark2"), random.color = FALSE, scale = c(3, 0.4),  max.words = input$wordcloud_input1)}
cloud_x <- recordPlot()  
  })

output$GO_cloud_word <- renderPlot({
  
validate(
need(input$checkbox_heatmap_GO != "", "Please select the type of GO enrichment performed to construct the wordcloud."),
need(input$heatmapT1 != "", "Please select the treatment to construct the wordcloud."),
need(input$checkbox_4 != "", "Please select the wordcloud option to construct the wordcloud."))
    
  
GO_word_cloud_ora()})
plotOutput("GO_cloud_word", width = "100%", height = 700)

#downloadhandler for cloud
output$downloadwordcloud <- downloadHandler(
filename = function(){paste0("wordcloud", sep=".", input$select_format_GO)
},
content = function(file){
if (input$select_format_GO == "jpeg"){
jpeg(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}
else if (input$select_format_GO == "png"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}
else if (input$select_format_GO == "pdf"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}
  
else if (input$select_format_GO == "tiff"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(GO_word_cloud_ora())
dev.off()}  
  })

#download tab for heatmap
output$Download_heat_map <- downloadHandler(
filename = function(){paste0("heatmap", input$select_format_GO, Sys.Date(), sep = ".")},
content = function(file){
if (input$select_format_GO == "jpeg"){
jpeg(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}
else if (input$select_format_GO == "png"){
png(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}
else if (input$select_format_GO == "pdf"){
pdf(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}
  
else if (input$select_format_GO == "tiff"){
tiff(file, width = input$Download_heat_input1, height = input$Download_heat_input2, res = input$Download_heat_input3, units = "cm")
print(final_heat_map_plot())
dev.off()}  
})
```

### Heatmap table

```{r, echo=FALSE}
 output$Table_output_3 <- DT::renderDataTable({final_gse_table()}, options = list(scroller = TRUE, scrollY = 510, scrollX = TRUE, pageLength = 25))
 DT::dataTableOutput("Table_output_3")
```

# Pathway enrichment analysis

## Sidebar {.sidebar data-width="350"}

```{r, echo= FALSE}
selectInput(inputId = "select_omics_GO_path", label = h5(strong("Omics Type")), choices = c("Transcriptomics", "Proteomics"))

checkboxGroupInput(inputId = "checkbox_KEGG", label = h5(strong("Select Pathway analysis Method")), choices = list("Over-Representation analysis", "Gene Set Enrichment Analysis", "Network Topology Analysis (Human)", "ReactomePA (Human)", "STRING"), inline = FALSE)
numericInput(inputId = "cutoff_KEGG",  label = h6(strong("Pvalue cutoff")), value = 0, min = 0, max = 20, step = 0.01)
selectInput(inputId = "pA_method2", label = h5(strong("pAdjust Method")), choices = c("None" =1, "holm" = 2, "hochberg"= 3, "hommel"= 4, "bonferroni"= 5, "Benjamini & Hochberg(BH)" = 6, "Benjamini & Yekutieli(BY)" = 7, "fdr" = 8 ))
selectInput(inputId = "Pathway_database", label = h5(strong("Databases for Network topology analysis)")), choices = c("biocarta", "panther", "nci", "pharmgkb"))
actionButton(inputId = "submit_KEGG", "Go!")
checkboxGroupInput(inputId = "pathway_T1", label = h5(strong("Pathway enrichment result")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"),inline = TRUE)
downloadButton(inputId = "KEGG_result", label = "Download", icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")

downloadHandler(
filename = function(){
if (input$pathway_T1 == "Treatment-1")
{paste("Pathway_result1", ".csv", sep = "")}
else if (input$pathway_T1 == "Treatment-2")
{paste("Pathway_result2",".csv", sep = "")}
else if (input$pathway_T1 == "Treatment-3")
{paste("Pathway_result3", ".csv",  sep = "")}
else if (input$pathway_T1 == "Treatment-4")
{paste("Pathway_result4", ".csv",  sep = "")}
},
content = function(file){
if (input$pathway_T1 == "Treatment-1") {
write.csv(KEGG_final_table_1(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-2"){
write.csv(KEGG_final_table_2(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-3") {
write.csv(KEGG_final_table_3(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-4") {
write.csv(KEGG_final_table_4(), file, row.names = FALSE)
}
})
```

## Column {.tabset}

### Pathway result-1

```{r, echo= FALSE}
keg_spec_1 <- reactive({
if (input$select1 == 1) {org_kegg_1 <- "hsa" } 
else if (input$select1 == 2) {org_kegg_1 <- "gga"}
else if (input$select1 == 3) {org_kegg_1 <- "ssc" }
else if (input$select1 == 4) {org_kegg_1 <- "bta" }
})
#For SPIA(NTA)
keg_spec_2 <- reactive({
if (input$select1 == 1) {org_kegg_1 <- "hsapiens" } 
else if (input$select1 == 2) {org_kegg_1 <- "ggallus"}
else if (input$select1 == 3) {org_kegg_1 <- "sscrofa" }
else if (input$select1 == 4) {org_kegg_1 <- "btaurus" }
})


#Code for ORA KEGG data
KEGG_table_ora_1 <- reactive({

if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
KEGG_output_result <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}

else if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- df_3_1()
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
KEGG_output_result_pro <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}
  })

#code for GSEA KEGG data
KEGG_table_gse_1 <- reactive({
if (c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC") 
GO_merge_3 <- GO_merge_2[, "logFC"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)
KEGG_output_result_1 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}

else if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){ df_3 <- as.data.frame(df_3_1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC") 
GO_merge_3 <- GO_merge_2[, "logFC"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)
KEGG_output_result_pro_1 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")   
}
  })

#code for reactomePA pathway data
reactome_table_1 <- reactive({
if (c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
KEGG_output_result <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}

else if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(df_3_1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
KEGG_output_result_pro <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1) }  
  })


#Network topology analysis
network_topology_1 <- reactive({

  if(c("Network Topology Analysis (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id", all = TRUE)
GO_merge_spai <- GO_merge[, c(1, 2,5)]
GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)
GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 2)]
GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]
de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))
de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)
de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)
colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"
de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)
final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)
final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))
names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID

#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]
all_spai_ref <- as.data.frame(all_spai_ref)
all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]
all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))
all_spai_ref_1 <- gsub(" ", "", all_spai_ref)

#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)
result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))
}

else if(c("Network Topology Analysis (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){ 
df_3 <- as.data.frame(df_3_1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot", all = TRUE)
GO_merge_spai <- GO_merge[, c(1, 3, 5)]
GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)
GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 3)]
GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]
de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))
de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)
de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)
colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"
de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)
final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)
final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))
names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID

#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]
all_spai_ref <- as.data.frame(all_spai_ref)
all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]
all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))
all_spai_ref_1 <- gsub(" ", "", all_spai_ref)

#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)
result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))}    
  })


#code for string enrichmnet
string_table_1 <- reactive({

if(c(1 %in% input$select1) && ("STRING" %in% input$checkbox_KEGG)) {
string_db <- STRINGdb$new(version = "11", species = 9606, score_threshold = 200, input_directory = "")
string_db
}
  
else if(c(2 %in% input$select1) && ("STRING" %in% input$checkbox_KEGG)) {
string_db <- STRINGdb$new(version = "11", species = 9031, score_threshold = 200, input_directory = "")
string_db
} 

else if(c(3 %in% input$select1) && ("STRING" %in% input$checkbox_KEGG)) {
string_db <- STRINGdb$new(version = "11", species = 9823, score_threshold = 200, input_directory = "")
string_db
}

else if(c(4 %in% input$select1) && ("STRING" %in% input$checkbox_KEGG)) {
string_db <- STRINGdb$new(version = "11", species = 9913, score_threshold = 200, input_directory = "")
string_db
}
   })

string_table_2 <- reactive({
  
if(c("STRING" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){  
df_3 <- as.data.frame(Filtertable1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

example1_mapped <- string_table_1()$map(GO_merge, "external_gene_name", removeUnmappedRows = TRUE)
}
else if(c("STRING" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(df_3_1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
example1_mapped <- string_table_1()$map(GO_merge, "external_gene_name", removeUnmappedRows = TRUE)
}
})


#final table output of pathway treatment-1
KEGG_final_table_1 <- eventReactive(input$submit_KEGG, {
withProgress(message = "Fetching enriched term from database for treatment-1", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}
KEGG_001 <- isolate(if (input$checkbox_KEGG == "Over-Representation analysis"){
as.data.frame(KEGG_table_ora_1()@result)}
else if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
as.data.frame(KEGG_table_gse_1()@result)}
else if (input$checkbox_KEGG == "ReactomePA (Human)"){
as.data.frame(reactome_table_1()@result)  
}
else if (input$checkbox_KEGG == "Network Topology Analysis (Human)"){
as.data.frame(network_topology_1())  
}
else if (input$checkbox_KEGG == "STRING"){
hits <- string_table_2()$STRING_id[1:200]  
enrichment_string <- string_table_1()$get_enrichment(hits)
}
)
KEGG_001
})
})

#code for selected column in Treatment-1
output$Pathway_table_1 <- DT::renderDataTable({
validate(need(input$checkbox_KEGG != "", "Please select the enrichment method, p-cutoff value and FDR correction method for pathway analysis.)"),
need(input$submit_KEGG, "Please select action button GO to perform  pathway enrichment analysis."
))
  
observeEvent(input$Pathway_table_4_rows_selected > 0, {
  showNotification("Please select only one row and same enriched pathway in all treatments.", duration = 10, type = "message")
}) 
KEGG_final_table_1()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))
DT::dataTableOutput("Pathway_table_1")

# ORA from this data we build the KEGG pathway
pathway_ora_plot_1 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(KEGG_table_ora_1()@result)
selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_1_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_1())

# Columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1, 2, 8)]
separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)

if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable1())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2, 3, 4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}

else if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(df_3_1())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)

#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}
})

#Pathway selected data for gsea treatment-1
pathway_gsea_plot_1 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(KEGG_table_gse_1()@result)
selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_1_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_1())
#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1, 2, 11)]
separated_pathway <- separate_rows(pathway_data_1, "core_enrichment", sep = "/", convert = TRUE)

if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable1())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2, 3, 4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()}

else if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable1_1())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()}
})

##########################
##########################
#pathway selected data for reactome treatment-1
pathway_react_plot_1 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(reactome_table_1()@result)
selected_rows_pathway_1 <- reactive({
GO_rows_pathway_1 <- input$Pathway_table_1_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]
})
pathway_data <- as.data.frame(selected_rows_pathway_1())
#columns selected from the reactome pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2, 8)]
separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)

if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable1())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3,4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()
}

else if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){

'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable1_1())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG,  by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}
})

```

### Pathway result-2

```{r, echo= FALSE}

#ORA KEGG DATA 2
KEGG_table_ora_2 <- reactive({
if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_2 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
KEGG_output_result_2 <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge_2$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}


else if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- Filtertable2_2()
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
KEGG_output_result_pro_2 <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}  
  })


#GSEA KEGG data 2
KEGG_table_gse_2 <- reactive({
  if (c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC.1") 
GO_merge_3 <- GO_merge_2[, "logFC.1"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)
KEGG_output_result_1 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}

else if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){ df_3 <- as.data.frame(Filtertable2_2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC") 
GO_merge_3 <- GO_merge_2[, "logFC"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)
KEGG_output_result_pro_1 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}
  })

network_topology_2 <- reactive({
if(c("Network Topology Analysis (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id", all = TRUE)
GO_merge_spai <- GO_merge[, c(1,2,5)]
GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)
GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 2)]
GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]
de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))
de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)
de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)
colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"
de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)
final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)
final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))
names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID
#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]
all_spai_ref <- as.data.frame(all_spai_ref)
all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]
all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))
all_spai_ref_1 <- gsub(" ", "", all_spai_ref)
#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)
result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))
}

else if(c("Network Topology Analysis (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){ 
df_3 <- as.data.frame(Filtertable2_2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot", all = TRUE)
GO_merge_spai <- GO_merge[, c(1, 3, 5)]
GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)
GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 3)]
GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]
de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))
de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)
de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)
colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"
de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)
final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)
final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))
names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID

#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]
all_spai_ref <- as.data.frame(all_spai_ref)
all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]
all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))
all_spai_ref_1 <- gsub(" ", "", all_spai_ref)

#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)
result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))}    
})

#code for reactomePA pathway data 2
reactome_table_2 <- reactive({

if (c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
KEGG_output_result <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}

else if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable2_2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
KEGG_output_result_pro <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1) }
})


#code for string network 2
string_table_2_2 <- reactive({
  
if(c("STRING" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){  
df_3 <- as.data.frame(Filtertable2())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

example1_mapped <- string_table_1()$map(GO_merge, "external_gene_name", removeUnmappedRows = TRUE)
}
else if(c("STRING" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(df_4_1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
example1_mapped <- string_table_1()$map(GO_merge, "external_gene_name", removeUnmappedRows = TRUE)
}
})



KEGG_final_table_2 <- eventReactive(input$submit_KEGG,{
withProgress(message = "Fetching enriched term from database for treatment-2", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}
KEGG_002 <- isolate(
if (input$checkbox_KEGG == "Over-Representation analysis"){
as.data.frame(KEGG_table_ora_2()@result)}
else if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
as.data.frame(KEGG_table_gse_2()@result)}
else if (input$checkbox_KEGG == "ReactomePA (Human)"){
as.data.frame(reactome_table_2()@result)}
else if (input$checkbox_KEGG == "Network Topology Analysis (Human)"){
as.data.frame(network_topology_2())}
else if (input$checkbox_KEGG == "STRING"){
hits <- string_table_2_2()$STRING_id[1:200]  
enrichment_string <- string_table_1()$get_enrichment(hits)
}
)
KEGG_002
})
})

output$Pathway_table_2 <- DT::renderDataTable({
validate(need(input$checkbox_KEGG != "", "Please select the enrichment method, p-cutoff value and FDR correction method for pathway analysis."),
need(input$submit_KEGG, "Please select action button GO to perform  pathway enrichment analysis!"
))
KEGG_final_table_2()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))
DT::dataTableOutput("Pathway_table_2")


#selection of rows for pathway treatment-2
pathway_ora_plot_2 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_2 <- as.data.frame(KEGG_table_ora_2()@result)
selected_rows_pathway_2 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_2_rows_selected
Selected_data_2[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_2())
#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,8)]
separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)

if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable2())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3,4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()
}

else if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable2_2())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)

#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}
})

#pathway selected data for gsea treatment-2
pathway_gsea_plot_2 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_2 <- as.data.frame(KEGG_table_gse_2()@result)
selected_rows_pathway_2 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_2_rows_selected
Selected_data_2[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_2())
#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1, 2, 11)]
separated_pathway <- separate_rows(pathway_data_1, "core_enrichment", sep = "/", convert = TRUE)

if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable2())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logFC to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3,4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()}

else if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable2_2())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logFC to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()}
})

##########################
##########################
#pathway selected data for reactome treatment-2
pathway_react_plot_2 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(reactome_table_2()@result)
selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_2_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_1())

#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,8)]
separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)

if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable2())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2, 3, 4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}

else if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){

'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable2_2())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG,  by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}
})
```

### Pathway result-3

```{r, echo= FALSE}
#ORA KEGG DATA 3
KEGG_table_ora_3 <- reactive({
if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_2 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
KEGG_output_result_2 <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge_2$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}


else if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- Filtertable3_3()
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
KEGG_output_result_pro_2 <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}
})


#GSEA KEGG data 3
KEGG_table_gse_3 <- reactive({
if (c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC.2") 
GO_merge_3 <- GO_merge_2[, "logFC.2"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)
KEGG_output_result_1 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}

else if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){ df_3 <- as.data.frame(Filtertable3_3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC") 
GO_merge_3 <- GO_merge_2[, "logFC"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)
KEGG_output_result_pro_1 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}
})


network_topology_3 <- reactive({
if(c("Network Topology Analysis (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id", all = TRUE)
GO_merge_spai <- GO_merge[, c(1,2,5)]
GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)
GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 2)]
GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]
de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))
de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)
de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC.2)
colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"
de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)
final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)
final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))
names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID
#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]
all_spai_ref <- as.data.frame(all_spai_ref)
all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]
all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))
all_spai_ref_1 <- gsub(" ", "", all_spai_ref)
#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)
result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))
}

else if(c("Network Topology Analysis (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){ 
df_3 <- as.data.frame(Filtertable3_3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot", all = TRUE)
GO_merge_spai <- GO_merge[, c(1, 3, 5)]
GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)
GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 3)]
GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]
de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))
de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)
de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)
colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"
de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)
final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)
final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))
names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID

#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]
all_spai_ref <- as.data.frame(all_spai_ref)
all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]
all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))
all_spai_ref_1 <- gsub(" ", "", all_spai_ref)

#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)
result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))}    
})


#Code for reactomePA pathway data 3
reactome_table_3 <- reactive({
if (c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
KEGG_output_result <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}

else if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable3_3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
KEGG_output_result_pro <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}
})


#code for string network 3
string_table_2_3 <- reactive({
  
if(c("STRING" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){  
df_3 <- as.data.frame(Filtertable3())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
example1_mapped <- string_table_1()$map(GO_merge, "external_gene_name", removeUnmappedRows = TRUE)
}
else if(c("STRING" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(df_5_1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
example1_mapped <- string_table_1()$map(GO_merge, "external_gene_name", removeUnmappedRows = TRUE)
}
})


KEGG_final_table_3 <- eventReactive(input$submit_KEGG,{
withProgress(message = "Fetching enriched term from database for treatment-3", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}
KEGG_003 <- isolate(if (input$checkbox_KEGG == "Over-Representation analysis"){
as.data.frame(KEGG_table_ora_3()@result)}
else if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
as.data.frame(KEGG_table_gse_3()@result)}
else if (input$checkbox_KEGG == "ReactomePA (Human)"){
as.data.frame(reactome_table_3()@result)}
else if (input$checkbox_KEGG == "Network Topology Analysis (Human)"){
as.data.frame(network_topology_3())}
else if (input$checkbox_KEGG == "STRING"){
hits <- string_table_2_3()$STRING_id[1:200]  
enrichment_string <- string_table_1()$get_enrichment(hits)
}
)
KEGG_003
})
})

output$Pathway_table_3 <- DT::renderDataTable({
validate(need(input$checkbox_KEGG != "", "Please select the enrichment method, p-cutoff value and FDR correction method for pathway analysis."),
need(input$submit_KEGG, "Please select action button GO to perform  pathway enrichment analysis!"
))
KEGG_final_table_3()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))
DT::dataTableOutput("Pathway_table_3")


#Selection of rows for pathway treatment-3
pathway_ora_plot_3 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_3 <- as.data.frame(KEGG_table_ora_3()@result)
selected_rows_pathway_3 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_3_rows_selected
Selected_data_3[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_3())
#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,8)]
separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)

if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable3())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3,4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()
}

else if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable3_3())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)

#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}
})


#pathway selected data for gsea treatment-3
pathway_gsea_plot_3 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_3 <- as.data.frame(KEGG_table_gse_3()@result)
selected_rows_pathway_3 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_3_rows_selected
Selected_data_3[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_3())
#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,11)]
separated_pathway <- separate_rows(pathway_data_1, "core_enrichment", sep = "/", convert = TRUE)

if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable3())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logFC to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3,4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()}

else if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable3_3())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logFC to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()}
})

##########################
##########################

#pathway selected data for reactome treatment-3
pathway_react_plot_3 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(reactome_table_3()@result)
selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_3_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_1())
#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,8)]
separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)

if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable3())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()
}

else if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable3_3())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}
})
```

### Pathway result-4

```{r, echo= FALSE}
#ORA KEGG DATA 4
KEGG_table_ora_4 <- reactive({
if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_2 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
KEGG_output_result_2 <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge_2$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}


else if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- Filtertable4_4()
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
KEGG_output_result_pro_2 <- clusterProfiler:: enrichKEGG(gene = as.vector(GO_merge$entrezgene_id), organism = keg_spec_1(), pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}
})


#GSEA KEGG data 4
KEGG_table_gse_4 <- reactive({
if (c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC.3") 
GO_merge_3 <- GO_merge_2[, "logFC.3"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)
KEGG_output_result_1 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}

else if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){ df_3 <- as.data.frame(Filtertable4_4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge_1 <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
GO_merge_1 <- as.data.frame(GO_merge_1)
GO_merge_2 <- dplyr::select(.data = GO_merge_1, "entrezgene_id", "logFC") 
GO_merge_3 <- GO_merge_2[, "logFC"]
names(GO_merge_3) <- as.character(GO_merge_2[, "entrezgene_id"])
GO_merge_3 <- sort(GO_merge_3, decreasing = TRUE)
KEGG_output_result_pro_1 <- clusterProfiler::gseKEGG(geneList = GO_merge_3, organism = keg_spec_1(), minGSSize = 5, eps = 0.0, maxGSSize = 1500, pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), verbose = TRUE, by = "fgsea")}
})


# NTA data for treatment 4
network_topology_4 <- reactive({
if(c("Network Topology Analysis (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id", all = TRUE)
GO_merge_spai <- GO_merge[, c(1,2,5)]
GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)
GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 2)]
GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]
de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))
de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)
de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC.3)
colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"
de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)
final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)
final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))
names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID

#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]
all_spai_ref <- as.data.frame(all_spai_ref)
all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]
all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))
all_spai_ref_1 <- gsub(" ", "", all_spai_ref)
#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)
result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))
}

else if(c("Network Topology Analysis (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){ 
df_3 <- as.data.frame(Filtertable4_4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot", all = TRUE)
GO_merge_spai <- GO_merge[, c(1, 3, 5)]
GO_merge_spai_2 <- left_join(df_3, GO_merge_spai)
GO_merge_spai_3 <- GO_merge_spai_2[, c(5, 3)]
GO_merge_spai_3 <- GO_merge_spai_3[!is.na(GO_merge_spai_3$entrezgene_id) & !duplicated(GO_merge_spai_3$entrezgene_id), ]
de_SPIA_1_1 <- sapply(GO_merge_spai_3$entrezgene_id, function(x) paste('ENTREZID:', x))
de_SPIA_1_1 <- gsub(" ", "", de_SPIA_1_1)
de_SPIA_1_1 <- cbind(de_SPIA_1_1, GO_merge_spai_3$logFC)
colnames(de_SPIA_1_1)[1] <- "ENTREZID"
colnames(de_SPIA_1_1)[2] <- "logFC"
de_SPIA_1_1 <- as.data.frame(de_SPIA_1_1)
final_spia_de_1 <- de_SPIA_1_1$logFC
names(final_spia_de_1) <- as.vector(de_SPIA_1_1$ENTREZID)
final_spia_de_1 <- as.numeric(as.character(final_spia_de_1))
names(final_spia_de_1) <- de_SPIA_1_1$ENTREZID

#data preparation for ref
all_spai_ref <- df_with_Etzgene_1[, 1]
all_spai_ref <- as.data.frame(all_spai_ref)
all_spai_ref <- all_spai_ref[!is.na(all_spai_ref) & !duplicated(all_spai_ref),  ]
all_spai_ref <- sapply(all_spai_ref, function(x) paste('ENTREZID:', x))
all_spai_ref_1 <- gsub(" ", "", all_spai_ref)

#database preparation
SPIA_database <- graphite::pathways(keg_spec_2(), input$Pathway_database)
result_spia_new_1 <- graphite::runSPIA(de = final_spia_de_1, all = all_spai_ref_1, pathwaySetName = paste(input$Pathway_database, "Ex1", sep = ""))}
})


#code for reactomePA pathway data 4
reactome_table_4 <- reactive({
if (c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")
KEGG_output_result <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1)}

else if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(Filtertable4_4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
KEGG_output_result_pro <- enrichPathway(gene = as.vector(GO_merge$entrezgene_id), organism = "human", pvalueCutoff = input$cutoff_KEGG, pAdjustMethod = adjust_method_1(), minGSSize = 1) }
})

string_table_2_4 <- reactive({
  
if(c("STRING" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){  
df_3 <- as.data.frame(Filtertable4())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "ENSEMBLGENE", by.y = "ensembl_gene_id")

example1_mapped <- string_table_1()$map(GO_merge, "external_gene_name", removeUnmappedRows = TRUE)
}
else if(c("STRING" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
df_3 <- as.data.frame(df_6_1())
df_with_Etzgene_1 <- as.data.frame(GO_table_001())
GO_merge <- merge(df_3, df_with_Etzgene_1, by.x = "UniProt ID", by.y = "uniprotswissprot")
example1_mapped <- string_table_1()$map(GO_merge, "external_gene_name", removeUnmappedRows = TRUE)
}
})


KEGG_final_table_4 <- eventReactive(input$submit_KEGG,{
withProgress(message = "Fetching enriched term from database for treatment-4", detail = "It will take some time.", value = 0, {
for(i in 1:20){
incProgress(1/15)}
KEGG_004 <- isolate(if (input$checkbox_KEGG == "Over-Representation analysis"){
as.data.frame(KEGG_table_ora_4()@result)}
else if (input$checkbox_KEGG == "Gene Set Enrichment Analysis"){
as.data.frame(KEGG_table_gse_4()@result)}
else if (input$checkbox_KEGG == "ReactomePA (Human)"){
as.data.frame(reactome_table_4()@result)}
else if (input$checkbox_KEGG == "Network Topology Analysis (Human)"){
as.data.frame(network_topology_4())}
else if (input$checkbox_KEGG == "STRING"){
hits <- string_table_2_4()$STRING_id[1:200]  
enrichment_string <- string_table_1()$get_enrichment(hits)
}
)
KEGG_004
})
})
output$Pathway_table_4 <- DT::renderDataTable({
validate(need(input$checkbox_KEGG != "", "Please select the enrichment method, p-cutoff value and FDR correction method for pathway analysis."),
need(input$submit_KEGG, "Please select action button GO to perform  pathway enrichment analysis!"
))
KEGG_final_table_4()},  options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))
DT::dataTableOutput("Pathway_table_4")

#selection of rows for pathway treatment-4
pathway_ora_plot_4 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_4 <- as.data.frame(KEGG_table_ora_4()@result)
selected_rows_pathway_2 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_4_rows_selected
Selected_data_4[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_2())
#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,8)]
separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)

if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable4())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()
}

else if(c("Over-Representation analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable4_4())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]

#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)

#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}
})


#pathway selected data for GSEA treatment-4
pathway_gsea_plot_4 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_4 <- as.data.frame(KEGG_table_gse_4()@result)
selected_rows_pathway_4 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_4_rows_selected
Selected_data_4[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_4())
#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,11)]
separated_pathway <- separate_rows(pathway_data_1, "core_enrichment", sep = "/", convert = TRUE)

if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable4())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logFC to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logFC to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()
}

else if(c("Gene Set Enrichment Analysis" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable4_4())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 3)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logFC to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(3, 2)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("core_enrichment" ="entrezgene_id")) %>% unique()}
})


##########################
##########################
#pathway selected data for reactome treatment-4
pathway_react_plot_4 <- reactive({
Selected_data_KEGG <- as.data.frame(GO_table_001())
Selected_data_1 <- as.data.frame(reactome_table_4()@result)
selected_rows_pathway_1 <- reactive({GO_rows_pathway_1 <- input$Pathway_table_4_rows_selected
Selected_data_1[sort(GO_rows_pathway_1), ]})
pathway_data <- as.data.frame(selected_rows_pathway_1())
#columns selected from the ORA pathway output with description, geneID
pathway_data_1 <- pathway_data[, c(1,2,8)]
separated_pathway <- separate_rows(pathway_data_1, "geneID", sep = "/", convert = TRUE)

if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Transcriptomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable4())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "ENSEMBLGENE", by.y= "ensembl_gene_id", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()
}

else if(c("ReactomePA (Human)" %in% input$checkbox_KEGG) && ("Proteomics" %in% input$select_omics_GO_path)){
'this is the uploaded data that will be used for the fetching of logfc value of the gene' 
P_data_filtered <- as.data.frame(Filtertable4_4())
'this dataframe can be used for the conversion of first column to gene name'
Heat_data_2 <- P_data_filtered[, c(1, 2)]
#this is to extract the two columns external_gene_name and logfc to merge with the gene ontology output
pathway_merge_1 <- merge(x = Heat_data_2, y = Selected_data_KEGG, by.x = "UniProt ID", by.y= "uniprotswissprot", all.x = TRUE)
#this is to extract the two columns entrez_gene_id and logfc to merge with the pathway analysis output
new_h1_pathway_merge <- pathway_merge_1[, c(2,3, 4)]
h_1_heatmap_4 <- inner_join(x = separated_pathway, y = new_h1_pathway_merge, by = c("geneID" ="entrezgene_id")) %>% unique()}
})

######################
##  Download tab    ##
######################
output$KEGG_result <- downloadHandler(
filename = function(){
if (input$pathway_T1 == "Treatment-1")
{paste("Pathway_result1", ".csv", sep = "")}
else if (input$pathway_T1 == "Treatment-2")
{paste("Pathway_result2",".csv", sep = "")}
else if (input$pathway_T1 == "Treatment-3")
{paste("Pathway_result3", ".csv",  sep = "")}
else if (input$pathway_T1 == "Treatment-4")
{paste("Pathway_result4", ".csv",  sep = "")}
},
content = function(file){
if (input$pathway_T1 == "Treatment-1") {
write.csv(KEGG_final_table_1(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-2"){
write.csv(KEGG_final_table_2(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-3") {
write.csv(KEGG_final_table_3(), file, row.names = FALSE)
}else if (input$pathway_T1 == "Treatment-4") {
write.csv(KEGG_final_table_4(), file, row.names = FALSE)
}
})
```

# Enriched pathway visualization

## Sidebar {.sidebar data-width="350"}

```{r, echo=FALSE}
checkboxGroupInput(inputId = "checkbox_Pathway", label = h5(strong("Pathway visualization")), choices = list("Pathway ORA",  "Pathway GSEA", "ReactomePA", "STRING PPI"), inline = TRUE)
fluidRow(column (4, selectInput( inputId = "Colour_high", label = strong("Up"), choices = c("None", "Red","Green", "Yellow", "Blue", "Grey"), selected = "Green", width = '100%')),
column (4, selectInput( inputId = "Colour_med", label = strong("No sign"), choices = c("None","Red", "Green", "Yellow", "Blue", "Grey"), selected = "Grey", width = '100%')),
column (4, selectInput( inputId = "Colour_low", label = strong("Down"), choices = c("None","Red", "Green", "Yellow", "Blue", "Grey"), selected = "Red", width = '100%')))
checkboxGroupInput(inputId = "T1", label = h5(strong("Treatments uploaded")), choices = list("Treatment-1", "Treatment-2", "Treatment-3", "Treatment-4"),inline = TRUE)
downloadButton(outputId = "download_pathway", label = "Download",  icon ("fas fa-download"), style = "color: #fff; background-color :#33B2FF")
br()
strong(p("ALERT:- Please rerun the pathway enrichment analysis and then select one enriched pathway in all treatments to switch to another enriched pathway visualization."))

downloadHandler(
filename = function(){
if(input$checkbox_Pathway == "Pathway ORA"){
paste0(pathway_ora_plot_1()[1, 1], "ora.pathview.png")}
else if (input$checkbox_Pathway == "Pathway GSEA"){
paste0(pathway_gsea_plot_1()[1, 1], "gsea.pathview.multi.png")}
else if (input$checkbox_Pathway == "ReactomePA"){
paste0("reactome_", pathway_react_plot_1()[1,1], ".png")}
else if (input$checkbox_Pathway == "STRING PPI"){
paste0("string_network_1.png")
}
    },
content <- function(file){
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "Pathway ORA")  
{file.copy(paste0(pathway_ora_plot_1()[1, 1], ".pathview.png"), file)}
if(input$T1 != "Treatment-1" && input$checkbox_Pathway == "Pathway ORA") 
{file.copy(paste0(pathway_ora_plot_1()[1, 1], ".pathview.multi.png"), file)}  
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "Pathway GSEA")  
{file.copy(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.png"), file)}
if(input$T1 != "Treatment-1" && input$checkbox_Pathway == "Pathway GSEA") 
{file.copy(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.multi.png"), file)}  
if(input$checkbox_Pathway == "ReactomePA") 
{file.copy(paste0("reactome_", pathway_react_plot_1()[1,1], ".png"), file)} 
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "STRING PPI") 
{file.copy(paste0("Img_1.png"), file)}
if(input$T1 == "Treatment-2" && input$checkbox_Pathway == "STRING PPI") 
{file.copy(paste0("Img_2.png"), file)} 
if(input$T1 == "Treatment-3" && input$checkbox_Pathway == "STRING PPI") 
{file.copy(paste0("Img_3.png"), file)}
if(input$T1 == "Treatment-4" && input$checkbox_Pathway == "STRING PPI") 
{file.copy(paste0("Img_4.png"), file)}
  },
contentType = "image/png"
)
```

## Column {.tabset}

### ORA pathway output

```{r, echo= FALSE}
# these codes for pathway ora treatment-1
kegg_pathview_1 <-reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_ora_plot_1())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
})

# these codes for pathway ora treatment-2
kegg_pathview_2 <- reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_ora_plot_2())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
heatmap_f1 <- merge(kegg_pathview_1(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)
})

# these codes for pathway ora treatment-3
kegg_pathview_3 <- reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_ora_plot_3())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
heatmap_f1 <- merge(kegg_pathview_2(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)  
  })

# these codes for pathway ora treatment-4
kegg_pathview_4 <- reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_ora_plot_4())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
heatmap_f1 <- merge(kegg_pathview_3(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)  
  })

#plotting pathways selected by user
pathway_plot_1 <- reactive({
if(input$checkbox_Pathway == "Pathway ORA" && input$T1 == "Treatment-1"){
pathway_plot_data_1 <- as.data.frame(kegg_pathview_1())
ORA_path_mtrx <- as.matrix(pathway_plot_data_1[, -1])
row.names(ORA_path_mtrx) <- pathway_plot_data_1[, 1]   
    
p1.out <- pathview(gene.data = ORA_path_mtrx, pathway.id = pathway_ora_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx, 0)))), bins = list(gene= 10), low = input$Colour_low , mid = input$Colour_med, high = input$Colour_high) }
  
else if(input$checkbox_Pathway == "Pathway ORA" && input$T1 == "Treatment-2"){
pathway_plot_data_1 <- as.data.frame(kegg_pathview_2())
ORA_path_mtrx <- as.matrix(pathway_plot_data_1[, -1])
row.names(ORA_path_mtrx) <- pathway_plot_data_1[, 1]  
  
  
p2.out <- pathview(gene.data = ORA_path_mtrx, pathway.id = pathway_ora_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx, 0)))), bins = list(gene= 10), low = input$Colour_low , mid = input$Colour_med, high = input$Colour_high) }
else if(input$checkbox_Pathway == "Pathway ORA" && input$T1 == "Treatment-3"){
pathway_plot_data_1 <- as.data.frame(kegg_pathview_3())
ORA_path_mtrx <- as.matrix(pathway_plot_data_1[, -1])
row.names(ORA_path_mtrx) <- pathway_plot_data_1[, 1]  
  
  
p3.out <- pathview(gene.data = ORA_path_mtrx, pathway.id = pathway_ora_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx, 0)))), bins = list(gene= 10), low = input$Colour_low , mid = input$Colour_med, high = input$Colour_high)}
  
else if(input$checkbox_Pathway == "Pathway ORA" && input$T1 == "Treatment-4"){
pathway_plot_data_1 <- as.data.frame(kegg_pathview_4())
ORA_path_mtrx <- as.matrix(pathway_plot_data_1[, -1])
row.names(ORA_path_mtrx) <- pathway_plot_data_1[, 1]  
  
p4.out <- pathview(gene.data = ORA_path_mtrx, pathway.id = pathway_ora_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx, 0)))), bins = list(gene= 10), low = input$Colour_low , mid = input$Colour_med, high = input$Colour_high)}
})

output$pathway_ora_plot <- renderImage({
  
validate(need(input$checkbox_Pathway != "", "Please select the type of enriched pathway visualization."),
         need(input$T1 != "", "Please select the treatment you want to visualize!")
         )  
  
observeEvent(input$checkbox_Pathway, {
  showNotification("Enriched pathway visulaization upto selected treatments.", type = "message", duration = 10)
})  
outfile <- if(input$T1 == "Treatment-1") {normalizePath(path = paste0(pathway_ora_plot_1()[1, 1], ".pathview.png"))}
      else if(input$T1 != "Treatment-1"){normalizePath(path = paste0(pathway_ora_plot_1()[1, 1], ".pathview.multi.png"))}
      
pathway_plot_1()
width <- session$clientData$output_pathway_ora_plot_width
height <- session$clientData$output_pathway_ora_plot_height
          
list(src = outfile,
     contentType = "image/png+xml",
    width = width,
    height = height)
}, deleteFile = FALSE)
imageOutput("pathway_ora_plot")
```

### GSEA pathway output

```{r, echo= FALSE}
# these codes for pathway GSEA treatment-1
kegg_pathview_gsea_1 <-reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_gsea_plot_1())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
names(h_plot_gse_1_1)[1] <- "geneID"
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
})

# these codes for pathway GSEA treatment-2
kegg_pathview_gsea_2 <- reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_gsea_plot_2())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
names(h_plot_gse_1_1)[1] <- "geneID"
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
heatmap_f1 <- merge(kegg_pathview_gsea_1(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)
})

# these codes for pathway GSEA treatment-3
kegg_pathview_gsea_3 <- reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_gsea_plot_3())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
names(h_plot_gse_1_1)[1] <- "geneID"
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
heatmap_f1 <- merge(kegg_pathview_gsea_2(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)  
  })

# these codes for pathway GSEA treatment-4
kegg_pathview_gsea_4 <- reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_gsea_plot_4())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
names(h_plot_gse_1_1)[1] <- "geneID"
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
heatmap_f1 <- merge(kegg_pathview_gsea_3(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)  
  })

#plotting pathways selected by user
pathway_plot_2 <- reactive({
if(input$checkbox_Pathway == "Pathway GSEA" && input$T1 == "Treatment-1"){
pathway_plot_data_12 <- as.data.frame(kegg_pathview_gsea_1())
ORA_path_mtrx_1 <- as.matrix(pathway_plot_data_12[, -1])
row.names(ORA_path_mtrx_1) <- pathway_plot_data_12[, 1]   
    
p5.out <- pathview(gene.data = ORA_path_mtrx_1, pathway.id = pathway_gsea_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx_1, 0)))), bins = list(gene= 10), low = input$Colour_low , mid = input$Colour_med, high = input$Colour_high) }

else if(input$checkbox_Pathway == "Pathway GSEA" && input$T1 == "Treatment-2"){
pathway_plot_data_12 <- as.data.frame(kegg_pathview_gsea_2())
ORA_path_mtrx_1 <- as.matrix(pathway_plot_data_12[, -1])
row.names(ORA_path_mtrx_1) <- pathway_plot_data_12[, 1]   
    
p5.out <- pathview(gene.data = ORA_path_mtrx_1, pathway.id = pathway_gsea_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx_1, 0)))), bins = list(gene= 10), low = input$Colour_low , mid = input$Colour_med, high = input$Colour_high) } 
  
else if(input$checkbox_Pathway == "Pathway GSEA" && input$T1 == "Treatment-3"){
pathway_plot_data_12 <- as.data.frame(kegg_pathview_gsea_3())
ORA_path_mtrx_1 <- as.matrix(pathway_plot_data_12[, -1])
row.names(ORA_path_mtrx_1) <- pathway_plot_data_12[, 1]   
    
p5.out <- pathview(gene.data = ORA_path_mtrx_1, pathway.id = pathway_gsea_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx_1, 0)))), bins = list(gene= 10), low = input$Colour_low , mid = input$Colour_med, high = input$Colour_high) }   
  
else if(input$checkbox_Pathway == "Pathway GSEA" && input$T1 == "Treatment-4"){
pathway_plot_data_12 <- as.data.frame(kegg_pathview_gsea_4())
ORA_path_mtrx_1 <- as.matrix(pathway_plot_data_12[, -1])
row.names(ORA_path_mtrx_1) <- pathway_plot_data_12[, 1]   
    
p5.out <- pathview(gene.data = ORA_path_mtrx_1, pathway.id = pathway_gsea_plot_1()[1, 1], species = keg_spec_1(), limit = list(gene = max(abs(round(ORA_path_mtrx_1, 0)))), bins = list(gene= 10), low = input$Colour_low , mid = input$Colour_med, high = input$Colour_high) }   
  
})
output$pathway_gsea_plot <- renderImage({
  
validate(need(input$checkbox_Pathway != "", "Please select the type of enriched pathway visualization."),
         need(input$T1 != "", "Please select the treatment that you want to visualize!")
         )  
  
outfile <- if(input$T1 == "Treatment-1") {normalizePath(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.png"))}
      else if(input$T1 != "Treatment-1"){normalizePath(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.multi.png"))}
pathway_plot_2()
width <- session$clientData$output_pathway_gsea_plot_width
height <- session$clientData$output_pathway_gsea_plot_height
          
list(src = outfile,
    width = width,
    height = height)
}, deleteFile = TRUE)
imageOutput("pathway_gsea_plot")
```

### Reactome pathway output

```{r, echo= FALSE}
# these codes is for pathway reactome treatment-1
reactome_pathview_1 <-reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_react_plot_1())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
})
# these codes is for pathway reactome treatment-2
reactome_pathview_2 <- reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_react_plot_2())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
heatmap_f1 <- merge(reactome_pathview_1(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)
})
# these codes is for pathway reactome treatment-3
reactome_pathview_3 <- reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_react_plot_3())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
heatmap_f1 <- merge(reactome_pathview_2(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)
})
# these codes is for pathway reactome treatment-4
reactome_pathview_4 <- reactive({
h_plot_data_gse_1 <- as.data.frame(pathway_react_plot_4())
h_plot_gse_1_1 <- h_plot_data_gse_1[, c(3, 4)]
heatmap_f4 <- as.data.frame(replace(h_plot_gse_1_1, is.na(h_plot_gse_1_1), 0))
heatmap_f1 <- merge(reactome_pathview_3(), heatmap_f4, by.y = "geneID", by.x = "geneID", all = TRUE) %>% replace(is.na(.), 0)
})
################################
#Reactome pathway visualization#
################################
reactome_pathway_plot_1 <- reactive({
  
if(input$checkbox_Pathway == "ReactomePA" && input$T1 == "Treatment-1"){
  
react_data_1 <-  as.data.frame(reactome_pathview_1())
  
react_data_1 <- data.frame(react_data_1, row.names = 1)
data("pathways.info", "sbgn.xmls")
  
SBGNview.obj <- SBGNview(
              gene.data = react_data_1, 
              gene.id.type = "entrez",
              input.sbgn =  pathway_react_plot_1()[1,1],
              output.file = "reactome",
              col.gene.low = input$Colour_low,
              col.gene.high = input$Colour_high, 
              col.gene.mid = input$Colour_med,
              max.gene.value = max(abs(round(react_data_1, 0))),
              min.gene.value = min(round(react_data_1, 0)),
              font.size = 2,   
              output.formats =  c("png"))
print(SBGNview.obj)
}
  
if(input$checkbox_Pathway == "ReactomePA" && input$T1 == "Treatment-2"){  
data("pathways.info", "sbgn.xmls") 
   
react_data_1 <-  as.data.frame(reactome_pathview_2())
  
react_data_1 <- data.frame(react_data_1, row.names = 1)
SBGNview.obj <- SBGNview(
              gene.data = react_data_1, 
              gene.id.type = "entrez",
              input.sbgn =  pathway_react_plot_1()[1,1],
              output.file = "reactome",
              col.gene.low = input$Colour_low,
              col.gene.high = input$Colour_high, 
              col.gene.mid = input$Colour_med,
              max.gene.value = max(abs(round(react_data_1, 0))),
              min.gene.value = min(round(react_data_1, 0)),
              font.size = 2,
              output.formats =  c("png"))
print(SBGNview.obj)
}
  
if(input$checkbox_Pathway == "ReactomePA" && input$T1 == "Treatment-3"){
data("pathways.info", "sbgn.xmls") 
   
react_data_1 <-  as.data.frame(reactome_pathview_3())
  
react_data_1 <- data.frame(react_data_1, row.names = 1)
SBGNview.obj <- SBGNview(
              gene.data = react_data_1, 
              gene.id.type = "entrez",
              input.sbgn =  pathway_react_plot_1()[1,1],
              output.file = "reactome",
              col.gene.low = input$Colour_low,
              col.gene.high = input$Colour_high, 
              col.gene.mid = input$Colour_med,
              max.gene.value = max(abs(round(react_data_1, 0))),
              min.gene.value = min(round(react_data_1, 0)),
              font.size = 2,
              output.formats =  c("png"))
print(SBGNview.obj)  
  
} 
  
if(input$checkbox_Pathway == "ReactomePA" && input$T1 == "Treatment-4"){
data("pathways.info", "sbgn.xmls") 
   
react_data_1 <-  as.data.frame(reactome_pathview_4())
  
react_data_1 <- data.frame(react_data_1, row.names = 1)
SBGNview.obj <- SBGNview(
              gene.data = react_data_1, 
              gene.id.type = "entrez",
              input.sbgn =  pathway_react_plot_1()[1,1],
              output.file = "reactome",
              col.gene.low = input$Colour_low,
              col.gene.high = input$Colour_high, 
              col.gene.mid = input$Colour_med,
              max.gene.value = max(abs(round(react_data_1, 0))),
              min.gene.value = min(round(react_data_1, 0)),
              font.size = 2,
              output.formats =  c("png"))
print(SBGNview.obj)  
  
} 
  
})
output$pathway_reactome_plot <- renderImage({
  
validate(need(input$checkbox_Pathway != "", "Please select the type of enriched pathway visualization."),
         need(input$T1 != "", "Please select the treatment that you want to visualize!")
         )   
outfile <- normalizePath(paste0("reactome_", pathway_react_plot_1()[1,1], ".png"))
reactome_pathway_plot_1() 
width <- session$clientData$output_pathway_reactome_plot_width
height <- session$clientData$output_pathway_reactome_plot_height 
list(src = outfile,
width = width,
height = height)
}, deleteFile = FALSE)
imageOutput("pathway_reactome_plot")


```

### STRING network

```{r, echo=FALSE}

output$plot_string <- renderImage({
  
validate(need(input$checkbox_Pathway != "", "Please select the STRING PPI checkbox."),
         need(input$T1 != "", "Please select the treatment that you want to visualize!")
         )  
 
 if(input$checkbox_Pathway > 0){
withProgress(message = "Constructing protein protein interaction.",  detail = "It will take some time.", value = 0,
{
for(i in 1:10)
{incProgress(1/15)
 Sys.sleep(0.1)}  
})}
  
if (c("STRING PPI" %in% input$checkbox_Pathway) && ("Treatment-1" %in% input$T1)) {

rbPal <- colorRampPalette(c("red", "white", "green"))

string_net_1 <- string_table_2()
string_net_2 <- string_net_1$STRING_id[1:200]
string_net_1$Col <- rbPal(10)[as.numeric(cut(string_net_1$logFC,breaks = 10))]
payload_id <- string_table_1()$post_payload(string_net_1$STRING_id, colors = string_net_1$Col)  


string_table_1()$get_png(string_net_2, payload_id = payload_id,  file = "network1.png")  

Img_1  <- image_read(normalizePath(paste0("network1.png")))
Img_1 <- image_draw(image = Img_1)

legend("bottomleft", legend = c("from curated databases", "experimentally determined", "gene neighborhood", "gene fusions", "gene co-occurrence", "textmining", "co-expression", "protein homology"), col = c("deepskyblue1", "pink", "green", "red", "blue3", "darkolivegreen1", "black", "darkorchid1"), title = "Interactions", lty = 6,lwd = 4, bty = "n")

legend("topright", legend = c("up", "no sign", "down"), col = c(input$Colour_high, input$Colour_med, input$Colour_low), title = "regulation (Halo)", lty = 10,lwd = 18, bty = "n")

print(Img_1)
 
image_write(Img_1, path = "Img_1.png", format = 'png')
}

else if (c("STRING PPI" %in% input$checkbox_Pathway) && ("Treatment-2" %in% input$T1)) {
rbPal <- colorRampPalette(c('red', 'white', 'green'))

string_net_1 <- string_table_2_2()
string_net_2 <- string_net_1$STRING_id[1:200]
string_net_1$Col <- rbPal(10)[as.numeric(cut(string_net_1$logFC,breaks = 10))]
payload_id <- string_table_1()$post_payload(string_net_1$STRING_id, colors = string_net_1$Col)  
string_table_1()$get_png(string_net_2, payload_id = payload_id,  file = "network2.png")

Img_2  <- image_read(normalizePath(paste0("network2.png")))
Img_2 <- image_draw(image = Img_2)

legend("bottomleft", legend = c("from curated databases", "experimentally determined", "gene neighborhood", "gene fusions", "gene co-occurrence", "textmining", "co-expression", "protein homology"), col = c("deepskyblue1", "pink", "green", "red", "blue3", "darkolivegreen1", "black", "darkorchid1"), title = "Interactions", lty = 6,lwd = 4, bty = "n")

legend("topright", legend = c("up", "no sign", "down"), col = c(input$Colour_high, input$Colour_med, input$Colour_low), title = "regulation (Halo)", lty = 10,lwd = 18, bty = "n")

print(Img_2)
 

image_write(Img_2, path = "Img_2.png", format = 'png')
} 

  
else if (c("STRING PPI" %in% input$checkbox_Pathway) && ("Treatment-3" %in% input$T1)) {
rbPal <- colorRampPalette(c('red', 'white', 'green'))

string_net_1 <- string_table_2_3()
string_net_2 <- string_net_1$STRING_id[1:200]
string_net_1$Col <- rbPal(10)[as.numeric(cut(string_net_1$logFC,breaks = 10))]
payload_id <- string_table_1()$post_payload(string_net_1$STRING_id, colors = string_net_1$Col)  
string_table_1()$get_png(string_net_2, payload_id = payload_id,  file = "network3.png")

Img_3  <- image_read(normalizePath(paste0("network3.png")))
Img_3 <- image_draw(image = Img_3)

legend("bottomleft", legend = c("from curated databases", "experimentally determined", "gene neighborhood", "gene fusions", "gene co-occurrence", "textmining", "co-expression", "protein homology"), col = c("deepskyblue1", "pink", "green", "red", "blue3", "darkolivegreen1", "black", "darkorchid1"), title = "Interactions", lty = 6,lwd = 4, bty = "n")

legend("topright", legend = c("up", "no sign", "down"), col = c(input$Colour_high, input$Colour_med, input$Colour_low), title = "regulation (Halo)", lty = 10,lwd = 18, bty = "n")

print(Img_3)
 
image_write(Img_3, path = "Img_3.png", format = 'png')
} 

else if (c("STRING PPI" %in% input$checkbox_Pathway) && ("Treatment-4" %in% input$T1)) {
rbPal <- colorRampPalette(c('red', 'white', 'green'))

string_net_1 <- string_table_2_4()
string_net_2 <- string_net_1$STRING_id[1:200]
string_net_1$Col <- rbPal(10)[as.numeric(cut(string_net_1$logFC,breaks = 10))]
payload_id <- string_table_1()$post_payload(string_net_1$STRING_id, colors = string_net_1$Col)  
string_table_1()$get_png(string_net_2, payload_id = payload_id,  file = "network4.png")

Img_4  <- image_read(normalizePath(paste0("network4.png")))
Img_4 <- image_draw(image = Img_4)

legend("bottomleft", legend = c("from curated databases", "experimentally determined", "gene neighborhood", "gene fusions", "gene co-occurrence", "textmining", "co-expression", "protein homology"), col = c("deepskyblue1", "pink", "green", "red", "blue3", "darkolivegreen1", "black", "darkorchid1"), title = "Interactions", lty = 6,lwd = 4, bty = "n")

legend("topright", legend = c("up", "no sign", "down"), col = c(input$Colour_high, input$Colour_med, input$Colour_low), title = "regulation (Halo)", lty = 10,lwd = 18, bty = "n")

print(Img_4)
 
image_write(Img_4, path = "Img_4.png", format = 'png')
} 

outfile <- if(input$T1 == "Treatment-1"){normalizePath(path = paste0("Img_1.png"))}
          else if(input$T1 == "Treatment-2"){normalizePath(path = paste0("Img_2.png"))}
          else if(input$T1 == "Treatment-3"){normalizePath(path = paste0("Img_3.png"))}
          else if(input$T1 == "Treatment-4"){normalizePath(path = paste0("Img_4.png"))}

width <- session$clientData$output_plot_string_width
height <- session$clientData$output_plot_string_height
  
list(src = outfile,
     width = width,
     height = height,
     contentType = "image/png")
}, deleteFile = FALSE)
imageOutput("plot_string")   


######################
#Download tab pathway#
######################
output$download_pathway <- downloadHandler(
filename = function(){
if(input$checkbox_Pathway == "Pathway ORA"){
paste0(pathway_ora_plot_1()[1, 1], "ora.pathview.png")}
else if (input$checkbox_Pathway == "Pathway GSEA"){
paste0(pathway_gsea_plot_1()[1, 1], "gsea.pathview.multi.png")}
else if (input$checkbox_Pathway == "ReactomePA"){
paste0("reactome_", pathway_react_plot_1()[1,1], ".png")}
else if (input$checkbox_Pathway == "STRING PPI"){
paste0("string_network_1.png")
}
    },
content <- function(file){
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "Pathway ORA")  
{file.copy(paste0(pathway_ora_plot_1()[1, 1], ".pathview.png"), file)}
if(input$T1 != "Treatment-1" && input$checkbox_Pathway == "Pathway ORA") 
{file.copy(paste0(pathway_ora_plot_1()[1, 1], ".pathview.multi.png"), file)}  
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "Pathway GSEA")  
{file.copy(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.png"), file)}
if(input$T1 != "Treatment-1" && input$checkbox_Pathway == "Pathway GSEA") 
{file.copy(paste0(pathway_gsea_plot_1()[1, 1], ".pathview.multi.png"), file)}  
if(input$checkbox_Pathway == "ReactomePA") 
{file.copy(paste0("reactome_", pathway_react_plot_1()[1,1], ".png"), file)} 
if(input$T1 == "Treatment-1" && input$checkbox_Pathway == "STRING PPI") 
{file.copy(paste0("Img_1.png"), file)}
if(input$T1 == "Treatment-2" && input$checkbox_Pathway == "STRING PPI") 
{file.copy(paste0("Img_2.png"), file)} 
if(input$T1 == "Treatment-3" && input$checkbox_Pathway == "STRING PPI") 
{file.copy(paste0("Img_3.png"), file)}
if(input$T1 == "Treatment-4" && input$checkbox_Pathway == "STRING PPI") 
{file.copy(paste0("Img_4.png"), file)}
  },
contentType = "image/png"
)

```

# Literature info

## Sidebar {.sidebar data-width="350"}

```{r, echo= FALSE}
textInput(inputId = "text_literature", label = h5(strong("Literature search")), value = "", width = "100%")
numericInput(inputId = "literature_limit", label = h5(strong("Literature retrival limit")), value = "100", min = 10, max = 5000, step = 100, width = '100%')
actionButton(inputId = "literature_submit", "Submit")
```

## Column {.tabset}

### Literature info

```{r, echo= FALSE}
literature_search <- eventReactive(input$literature_submit, {europepmc::epmc_search(query = input$text_literature, limit = input$literature_limit, sort = "date")})
output$literature_result_1 <- DT::renderDataTable({
validate(need(input$text_literature != "", "Please provide input for lietrature search, example- Gene name, species, disease type, etc."),   
need(input$literature_limit != "", "Please provide input for limiting the retrieval of scientific lietrature; example 10-5000."),
need(input$literature_submit, "Please click on submit button to perform retrieval!")) 
  
  
withProgress(message = "Fetching information", detail = "According to the provided retrieval limit it will take time! ", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
  
literature_search()})},options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25, selection =  'single', extensions = 'Responsive'))
DT::dataTableOutput("literature_result_1")
#selection of one row for fetching abstract
selected_rows_literature <- reactive({
literature_rows <- input$literature_result_1_rows_selected
literature_search()[sort(literature_rows), ]})
```

### Abstract info

```{r, echo= FALSE}
selected_rows_abstract <- reactive({
  
if(is.null(input$literature_result_1_rows_selected))
    return(NULL)
  
literature_data <- as.data.frame(selected_rows_literature())
literature_data_1 <- literature_data[1, 3]
literature_detailes <- europepmc::epmc_details(literature_data_1, data_src = "med")
final_literature_1 <- literature_detailes[["basic"]]
final_literature_2 <- final_literature_1[, c(5,6,10,7,9,4)]
})
output$literature_selected <- DT::renderDataTable({
  
validate(need(input$literature_result_1_rows_selected != "", "Please provide input by selecting only one row at a time from lietrature search result table."))  
withProgress(message = "Fetching abstract;", detail = "Abstract availability depends on the data source!", value = 0, {
for(i in 1:10){
incProgress(1/10)
Sys.sleep(0.1)}
selected_rows_abstract()})},options = list(scroller = TRUE, scrollY = 500, scrollX = TRUE, pageLength = 25))
DT::dataTableOutput("literature_selected")
```

# Help

```{r, echo= FALSE}
h4(strong("The OMnalysis app permits users to visualize and analyze quantitative differential transcriptomics and proteomics data."))
p(strong("Investigate the features of application provided above, using a preloaded example of RNA-seq and label free relative quantitative data sets.
Upload your differential data up to four treatment at a time."))
h3("INSTRUCTIONS")
p("•	The app is hosted on shiny.io website:", strong("https://omnalysis.shinyapps.io/OMnalysis/"), a( "click here", href="https://omnalysis.shinyapps.io/OMnalysis/"))
p("•	Codes are freely available at Github:", strong("https://github.com/Punit201016/OMnalysis"), a("click here", href="https://github.com/Punit201016/OMnalysis"))
p("•	Step-by-step guide can be acessed by:", strong("https://github.com/Punit201016/OMnalysis"), a("click here", href="https://github.com/Punit201016/OMnalysis"))
p("•	You can run this app on your desktop after installing R base and RStudio.")
p("•	Once the environment is ready, install packages required for OMnalysis.")
p("•	Install R shiny supporting packages")
h4(code('Install.packages(c("flexdashboard", "dplyr", "shiny", "shinydashboard", "DT", "tidyverse", "shinythemes", "tidyr", "gplots", "tibble", "gridExtra", "RColorBrewer", "slickR", "devtools", "ggbiplot", "factoextra", "ggplot2", "data.table", "VennDiagram", "fields", "wordcloud", "SBGNview", "europepmc"))'))
p("Install Bioconductor packages using:", code('Install.packages("BiocManager")'))
h4("then",code('install.packages(c("AnnotationDbi", "Biobase", "BiocFileCache", "BiocGenerics", "BiocParallel", "BiocVersion", "biomaRt", "Biostrings", "clusterProfiler", "DO.db", "DOSE", "EnhancedVolcano", "enrichplot", "fgsea", "GO.db", "GOSemSim", "graph", "graphite", "IRanges", "KEGGgraph", "KEGGREST", "org.Bt.eg.db", "org.Gg.eg.db", "org.Hs.eg.db", "org.Ss.eg.db", "pathview", "qvalue", "reactome.db", "ReactomePA", "Rgraphviz", "S4Vectors", "XVector", "zlibbioc"))'))

```
